<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>JS Checkers — Strong AI</title>
  <meta name="description" content="High-quality JavaScript Checkers with mandatory captures, multi-jumps, and strong AI." />
  <style>
    /* Page-level polish only — game logic remains intact */
    html, body {
      height: 100%;
      background: #111;
    }
    body {
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }
  </style>
</head>
<body>

<script>
(() => {
  // High-quality Checkers — Mandatory-jump highlighting added
  // Human (White, uppercase) vs AI (Black, lowercase)
  // Paste and run in browser console.

  // ---------- UI setup ----------
  document.body.innerHTML = "";
  document.body.style.margin = "0";
  document.body.style.background = "#111";
  document.body.style.display = "flex";
  document.body.style.justifyContent = "center";
  document.body.style.alignItems = "flex-start";
  document.body.style.padding = "20px";
  document.body.style.fontFamily = "Arial, sans-serif";

  const container = document.createElement("div");
  document.body.appendChild(container);

  // Canvas
  const SIZE = 640;
  const TILE = SIZE / 8;
  const canvas = document.createElement("canvas");
  canvas.width = canvas.height = SIZE;
  canvas.style.boxShadow = "0 6px 18px rgba(0,0,0,0.6)";
  container.appendChild(canvas);
  const ctx = canvas.getContext("2d");

  // Controls panel
  const panel = document.createElement("div");
  panel.style.color = "white";
  panel.style.marginLeft = "20px";
  panel.style.width = "320px";
  container.appendChild(panel);

  panel.innerHTML = `
    <h2 style="margin:6px 0 12px 0;color:#fff">JS Checkers — Strong AI (Mandatory-jump highlight)</h2>
    <div style="margin-bottom:10px">Turn: <span id="turn">White</span></div>
    <div style="margin-bottom:10px">Status: <span id="status">Ready</span></div>
    <div style="margin-bottom:12px">Difficulty:
      <select id="difficulty">
        <option value="3">Easy (depth 3)</option>
        <option value="5" selected>Normal (depth 5)</option>
        <option value="7">Hard (depth 7)</option>
      </select>
    </div>
    <button id="undo" style="margin-right:8px">Undo</button>
    <button id="reset">Reset</button>
    <div style="margin-top:12px;font-size:13px;color:#ddd">
      Click a piece to select it, then click a destination. Captures are forced and multi-jumps supported.
    </div>
  `;

  const turnLabel = panel.querySelector("#turn");
  const statusLabel = panel.querySelector("#status");
  const difficulty = panel.querySelector("#difficulty");
  const undoBtn = panel.querySelector("#undo");
  const resetBtn = panel.querySelector("#reset");

  // ---------- Game state ----------
  // Uppercase = human (White), lowercase = AI (Black)
  // 'R' / 'r' = man, 'K' / 'k' = king
  let board = [
    ["", "r", "", "r", "", "r", "", "r"],
    ["r", "", "r", "", "r", "", "r", ""],
    ["", "r", "", "r", "", "r", "", "r"],
    ["", "", "", "", "", "", "", ""],
    ["", "", "", "", "", "", "", ""],
    ["R", "", "R", "", "R", "", "R", ""],
    ["", "R", "", "R", "", "R", "", "R"],
    ["R", "", "R", "", "R", "", "R", ""]
  ];

  let sideToMove = 'w'; // 'w' = human (uppercase), 'b' = AI (lowercase)
  let history = []; // move history for undo
  let selected = null;
  let legalMovesCache = [];
  const tt = new Map(); // transposition table

  // ---------- Helpers ----------
  function inBounds(x,y){ return x>=0 && x<8 && y>=0 && y<8; }
  function isDarkSquare(x,y){ return (x + y) % 2 === 1; }
  function pieceColor(p){ if (!p) return null; return p === p.toUpperCase() ? 'w' : 'b'; }
  function cloneBoard(b){ return b.map(r => r.slice()); }
  function boardKey(b, side){
    return b.flat().map(s => s ? s : '.').join('') + ' ' + side;
  }

  // ---------- Drawing ----------
  function drawBoard(){
    // compute mandatory capture starts for the side to move
    const mandatoryStarts = new Set();
    const allCaps = generateAllCaptures(sideToMove, board);
    if (allCaps.length){
      for (const m of allCaps){
        mandatoryStarts.add(m.sx + "," + m.sy);
      }
    }

    // board background
    for (let y=0;y<8;y++){
      for (let x=0;x<8;x++){
        const light = (x+y) % 2 === 0;
        ctx.fillStyle = light ? "#f0d9b5" : "#8b5a2b";
        ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
      }
    }

    // highlight mandatory pieces
    if (mandatoryStarts.size){
      for (let key of mandatoryStarts){
        const [sx, sy] = key.split(',').map(Number);
        // subtle pulsating ring
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(255,0,0,0.9)';
        ctx.lineWidth = 4;
        ctx.arc(sx*TILE + TILE/2, sy*TILE + TILE/2, TILE*0.42, 0, Math.PI*2);
        ctx.stroke();
      }
    }

    // highlight selected and legal moves
    if (selected){
      ctx.fillStyle = "rgba(255,255,0,0.35)";
      ctx.fillRect(selected.x*TILE, selected.y*TILE, TILE, TILE);
      for (let m of legalMovesCache){
        if (m.sx === selected.x && m.sy === selected.y){
          // mark landing squares for that move
          const last = m.path[m.path.length - 1];
          ctx.beginPath();
          ctx.fillStyle = m.captures.length ? "rgba(255,0,0,0.45)" : "rgba(0,0,0,0.25)";
          ctx.arc(last.x*TILE + TILE/2, last.y*TILE + TILE/2, TILE/6, 0, Math.PI*2);
          ctx.fill();
        }
      }
    }

    // draw pieces
    for (let y=0;y<8;y++){
      for (let x=0;x<8;x++){
        const p = board[y][x];
        if (!p) continue;
        const isWhite = p === p.toUpperCase();
        // piece circle
        ctx.beginPath();
        ctx.fillStyle = isWhite ? "#fff" : "#000";
        ctx.strokeStyle = "#222";
        ctx.lineWidth = 2;
        const cx = x*TILE + TILE/2, cy = y*TILE + TILE/2;
        ctx.arc(cx, cy, TILE*0.36, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();
        // inner color for human vs ai
        ctx.beginPath();
        ctx.fillStyle = isWhite ? "#e23b3b" : "#222";
        ctx.arc(cx, cy, TILE*0.28, 0, Math.PI*2);
        ctx.fill();
        // crown for king
        if (p.toLowerCase() === 'k'){
          ctx.fillStyle = "#ffd700";
          ctx.font = `${Math.floor(TILE*0.45)}px Arial`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("★", cx, cy+2);
        }
      }
    }

    turnLabel.textContent = sideToMove === 'w' ? 'White' : 'Black (AI)';
  }

  // ---------- Move representation ----------
  // move = { sx, sy, path:[{x,y},...], captures:[{x,y},...]} 
  function makeMoveObject(sx,sy,path,captures){
    return { sx, sy, path, captures, promotion: false };
  }

  // ---------- Move generation ----------
  // Men: white (uppercase) move up (dy = -1). Black moves down (dy = +1).
  function getAllCaptureMovesForPiece(sx,sy,bState){
    const piece = bState[sy][sx];
    if (!piece) return [];
    const color = pieceColor(piece);
    const startIsKing = piece.toLowerCase() === 'k';
    const results = [];

    function recurse(x,y, boardSoFar, path, caps, becameKing, visitedCaps){
      let foundAny = false;
      const isKingNow = startIsKing || becameKing;
      const dirs = isKingNow ? [[1,1],[1,-1],[-1,1],[-1,-1]] : (color === 'w' ? [[1,-1],[-1,-1]] : [[1,1],[-1,1]]);
      for (let [dx,dy] of dirs){
        const mx = x + dx, my = y + dy;
        const lx = x + 2*dx, ly = y + 2*dy;
        if (!inBounds(mx,my) || !inBounds(lx,ly)) continue;
        const mid = boardSoFar[my][mx];
        const land = boardSoFar[ly][lx];
        if (!mid || pieceColor(mid) === color) continue;
        if (land) continue;
        const capId = `${mx},${my}`;
        if (visitedCaps.has(capId)) continue;
        // simulate
        const nb = boardSoFar.map(r => r.slice());
        nb[my][mx] = "";
        nb[y][x] = "";
        nb[ly][lx] = piece;
        visitedCaps.add(capId);
        const newPath = path.concat([{x:lx,y:ly}]);
        const newCaps = caps.concat([{x:mx,y:my}]);
        const promoted = (piece === 'R' && ly === 0) || (piece === 'r' && ly === 7);
        recurse(lx, ly, nb, newPath, newCaps, becameKing || promoted, visitedCaps);
        visitedCaps.delete(capId);
        foundAny = true;
      }
      if (!foundAny && path.length){
        results.push(makeMoveObject(sx, sy, path, caps));
      }
      return foundAny;
    }

    recurse(sx, sy, bState.map(r => r.slice()), [], [], false, new Set());
    return results;
  }

  function generateAllCaptures(side, bState){
    let all = [];
    for (let y=0;y<8;y++){
      for (let x=0;x<8;x++){
        const p = bState[y][x];
        if (!p) continue;
        if (pieceColor(p) === (side === 'w' ? 'w' : 'b')){
          const caps = getAllCaptureMovesForPiece(x,y,bState);
          if (caps.length) all = all.concat(caps);
        }
      }
    }
    if (all.length){
      let maxCap = Math.max(...all.map(m => m.captures.length));
      all = all.filter(m => m.captures.length === maxCap);
    }
    return all;
  }

  function generateSimpleMoves(side, bState){
    const moves = [];
    for (let y=0;y<8;y++){
      for (let x=0;x<8;x++){
        const p = bState[y][x];
        if (!p) continue;
        if (pieceColor(p) !== (side === 'w' ? 'w' : 'b')) continue;
        const isKing = p.toLowerCase() === 'k';
        const dirs = isKing ? [[1,1],[1,-1],[-1,1],[-1,-1]] : (pieceColor(p) === 'w' ? [[1,-1],[-1,-1]] : [[1,1],[-1,1]]);
        for (let [dx,dy] of dirs){
          const nx = x + dx, ny = y + dy;
          if (!inBounds(nx,ny)) continue;
          if (!bState[ny][nx]) moves.push(makeMoveObject(x,y, [{x:nx,y:ny}], []));
        }
      }
    }
    return moves;
  }

  function generateLegalMovesFor(side, bState){
    const caps = generateAllCaptures(side, bState);
    if (caps.length) return caps;
    return generateSimpleMoves(side, bState);
  }

  // ---------- Make / Undo moves ----------
  function applyMove(move){
    const snapshot = { boardBefore: cloneBoard(board), sideBefore: sideToMove };
    history.push(snapshot);
    const piece = board[move.sy][move.sx];
    board[move.sy][move.sx] = "";
    for (let c of move.captures) board[c.y][c.x] = "";
    const last = move.path[move.path.length - 1];
    let placed = piece;
    if (piece === 'R' && last.y === 0) placed = 'K';
    if (piece === 'r' && last.y === 7) placed = 'k';
    board[last.y][last.x] = placed;
    sideToMove = sideToMove === 'w' ? 'b' : 'w';
  }

  function undo(){
    const snap = history.pop();
    if (!snap) return;
    board = snap.boardBefore;
    sideToMove = snap.sideBefore;
  }

  // ---------- Evaluation ----------
  const VAL = { r: 100, k: 180 };
  function evaluateBoard(b){
    let score = 0;
    for (let y=0;y<8;y++){
      for (let x=0;x<8;x++){
        const p = b[y][x];
        if (!p) continue;
        const val = VAL[p.toLowerCase()] || 0;
        const sign = p === p.toUpperCase() ? 1 : -1;
        const advancement = p === 'R' ? (7 - y) * 2 : p === 'r' ? y * 2 : 0;
        score += sign * (val + advancement);
      }
    }
    return score * (sideToMove === 'w' ? 1 : -1);
  }

  // ---------- Move ordering / Search ----------
  function moveOrderScore(m){ if (m.captures && m.captures.length) return 1000 + m.captures.length * 100; return 0; }

  function posKey(){ return boardKey(board, sideToMove); }

  let nodes = 0;
  function alphaBeta(depth, alpha, beta, maximizing){
    nodes++;
    const key = posKey() + ' ' + depth + ' ' + (maximizing ? '1' : '0');
    if (tt.has(key)) return tt.get(key);
    if (depth === 0){ const v = evaluateBoard(board); tt.set(key, v); return v; }
    const side = maximizing ? (sideToMove === 'w' ? 'w' : 'b') : (sideToMove === 'w' ? 'b' : 'w');
    let moves = generateLegalMovesFor(side, board);
    if (moves.length === 0){ const v = maximizing ? -100000 : 100000; tt.set(key, v); return v; }
    moves.sort((a,b) => moveOrderScore(b) - moveOrderScore(a));
    if (maximizing){
      let value = -Infinity;
      for (let m of moves){ applyMove(m); const val = alphaBeta(depth - 1, alpha, beta, false); undo(); if (val > value) value = val; if (val > alpha) alpha = val; if (alpha >= beta) break; }
      tt.set(key, value); return value;
    } else {
      let value = Infinity;
      for (let m of moves){ applyMove(m); const val = alphaBeta(depth - 1, alpha, beta, true); undo(); if (val < value) value = val; if (val < beta) beta = val; if (alpha >= beta) break; }
      tt.set(key, value); return value;
    }
  }

  async function aiMove(maxDepth){
    statusLabel.textContent = "AI thinking...";
    turnLabel.textContent = "Black (AI)";
    nodes = 0; tt.clear();
    let best = null;
    for (let d=1; d<=maxDepth; d++){
      let moves = generateLegalMovesFor('b', board);
      if (moves.length === 0) break;
      moves.sort((a,b) => moveOrderScore(b) - moveOrderScore(a));
      let bestVal = -Infinity;
      for (let m of moves){ applyMove(m); const v = alphaBeta(d-1, -Infinity, Infinity, true); undo(); if (v > bestVal){ bestVal = v; best = m; } }
      statusLabel.textContent = `Searched depth ${d} — nodes ${nodes} — best ${bestVal}`;
      await new Promise(r => setTimeout(r, 20));
    }
    if (best){ applyMove(best); drawBoard(); statusLabel.textContent = "AI moved"; }
    else statusLabel.textContent = "AI has no moves";
  }

  // ---------- Game end detection ----------
  function gameStatus(){ const moves = generateLegalMovesFor(sideToMove === 'w' ? 'w' : 'b', board); if (moves.length === 0){ const winner = sideToMove === 'w' ? 'Black (AI)' : 'White'; return { result: 'ended', winner }; } return { result: 'playing' }; }

  // ---------- Click handling ----------
  canvas.onclick = async (ev) => {
    if (sideToMove !== 'w') return; // human is white only here
    const rect = canvas.getBoundingClientRect();
    const cx = ev.clientX - rect.left;
    const cy = ev.clientY - rect.top;
    const x = Math.floor(cx / TILE), y = Math.floor(cy / TILE);
    if (!inBounds(x,y) || !isDarkSquare(x,y)) return;

    const p = board[y][x];

    // compute mandatory capture starts
    const allCaps = generateAllCaptures(sideToMove, board);
    const mandatoryStarts = new Set(allCaps.map(m => m.sx + "," + m.sy));

    if (!selected){
      if (p && pieceColor(p) === 'w'){
        // if mandatory captures exist, only allow selecting those pieces
        if (mandatoryStarts.size && !mandatoryStarts.has(x+","+y)) return;
        selected = { x, y };
        legalMovesCache = generateLegalMovesFor('w', board);
      }
    } else {
      const all = generateLegalMovesFor('w', board);
      const candidate = all.find(m => m.sx === selected.x && m.sy === selected.y && m.path[m.path.length - 1].x === x && m.path[m.path.length - 1].y === y);
      if (candidate){
        applyMove(candidate);
        selected = null; legalMovesCache = [];
        drawBoard();
        const st = gameStatus();
        if (st.result === 'playing'){
          sideToMove = 'b'; turnLabel.textContent = 'Black (AI)';
          await aiMove(Number(difficulty.value));
          const st2 = gameStatus();
          if (st2.result === 'ended') statusLabel.textContent = `Game over — ${st2.winner} wins`;
          else statusLabel.textContent = 'Your move';
        } else {
          statusLabel.textContent = `Game over — ${st.winner} wins`;
        }
      } else {
        if (p && pieceColor(p) === 'w'){
          if (mandatoryStarts.size && !mandatoryStarts.has(x+","+y)){ selected = null; legalMovesCache = []; return; }
          selected = { x, y };
          legalMovesCache = generateLegalMovesFor('w', board);
        } else { selected = null; legalMovesCache = []; }
      }
    }
    drawBoard();
  };

  undoBtn.onclick = () => { undo(); if (history.length) undo(); selected = null; legalMovesCache = []; drawBoard(); statusLabel.textContent = "Undone"; };

  resetBtn.onclick = () => {
    board = [
      ["", "r", "", "r", "", "r", "", "r"],
      ["r", "", "r", "", "r", "", "r", ""],
      ["", "r", "", "r", "", "r", "", "r"],
      ["", "", "", "", "", "", "", ""],
      ["", "", "", "", "", "", "", ""],
      ["R", "", "R", "", "R", "", "R", ""],
      ["", "R", "", "R", "", "R", "", "R"],
      ["R", "", "R", "", "R", "", "R", ""]
    ];
    sideToMove = 'w'; history = []; selected = null; legalMovesCache = []; tt.clear(); drawBoard(); statusLabel.textContent = "Reset";
  };

  // ---------- Start ----------
  drawBoard(); statusLabel.textContent = "Ready";
})();
</script>

</body>
</html>
