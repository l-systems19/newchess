<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>JS Checkers — Mobile Friendly</title>
  <style>
    :root{
      --bg: #0b0b0c;
      --panel-bg: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));
      --accent: #e23b3b;
      --muted: #cfcfcf;
      --card-shadow: 0 8px 30px rgba(0,0,0,0.6);
      --radius: 12px;
    }

    html,body{ height:100%; }
    body{
      margin:0!important;
      min-height:100vh;
      background:var(--bg);
      display:flex;
      justify-content:center;
      align-items:flex-start;
      padding:20px;
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      color:#fff;
      box-sizing:border-box;
    }

    /* container created by the script is body > div:first-child */
    body > div:first-child{
      display:flex;
      gap:20px;
      align-items:flex-start;
      width:100%;
      max-width:1200px;
      padding:8px;
      box-sizing:border-box;
      flex-wrap:nowrap;
    }

    /* Responsive canvas visual size */
    body > div:first-child > canvas{
      width: min(92vmin, 640px) !important;
      height: auto !important;
      max-width:100%;
      border-radius:12px;
      box-shadow:var(--card-shadow);
      touch-action: none; /* ensures touchstart handling is reliable */
      -webkit-tap-highlight-color: transparent;
      background: transparent;
    }

    body > div:first-child > div{
      width:320px;
      max-width:calc(100% - 40px);
      padding:14px 16px;
      border-radius:var(--radius);
      background:var(--panel-bg);
      box-shadow:var(--card-shadow);
      position:sticky;
      top:24px;
      align-self:flex-start;
      color:var(--muted);
      box-sizing:border-box;
    }

    body > div:first-child > div h2{
      margin:6px 0 12px 0;
      color:#fff;
      font-size:18px;
      line-height:1.05;
    }

    #turn, #status { font-weight:700; color:#fff; display:inline-block; margin-left:6px; background: rgba(255,255,255,0.03); padding:3px 8px; border-radius:999px; font-size:13px; }
    #difficulty{ display:inline-block; margin-left:8px; padding:6px 8px; border-radius:8px; border:1px solid rgba(255,255,255,0.06); background: rgba(0,0,0,0.25); color:#fff; font-size:13px; outline:none; vertical-align:middle; }
    button#undo, button#reset{ padding:8px 12px; border-radius:10px; border:none; cursor:pointer; font-weight:600; margin-top:10px; transition: transform .08s ease; box-shadow:0 6px 18px rgba(0,0,0,0.45); background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(0,0,0,0.2)); color:#fff; }
    button#undo{ margin-right:8px; }
    button#undo:hover, button#reset:hover{ transform: translateY(-2px); }
    button:active{ transform: translateY(0); }
    #panelHelper{ margin-top:12px; font-size:13px; color:#ddd; }

    @media (max-width:880px){
      body{ padding:16px; }
      body > div:first-child{ flex-direction:column; gap:12px; align-items:center; }
      body > div:first-child > div{ width:100%; position:static; padding:12px; top:auto; }
      body > div:first-child > div h2{ font-size:16px; }
      #difficulty{ margin-top:8px; display:block; }
      button#undo, button#reset{ width:48%; display:inline-block; }
      body > div:first-child > canvas{ width: min(90vw, 640px) !important; }
    }

    /* Focus */
    #difficulty:focus, button:focus { outline: 3px solid rgba(226,59,59,0.22); outline-offset:2px; }
  </style>
</head>
<body>
  <!-- Your original script clears body.innerHTML and re-creates the UI.
       That's fine — keep the script logic intact; we only add scaling & touch helpers. -->
  <script>
(() => {
  // High-quality Checkers — Mandatory-jump highlighting added
  // Human (White, uppercase) vs AI (Black, lowercase)
  // Paste and run in browser console.

  // ---------- UI setup ----------
  document.body.innerHTML = "";
  document.body.style.margin = "0";
  document.body.style.background = "#111";
  document.body.style.display = "flex";
  document.body.style.justifyContent = "center";
  document.body.style.alignItems = "flex-start";
  document.body.style.padding = "20px";
  document.body.style.fontFamily = "Arial, sans-serif";

  const container = document.createElement("div");
  document.body.appendChild(container);

  // Canvas
  const SIZE = 640;
  const TILE = SIZE / 8;
  const canvas = document.createElement("canvas");

  // === High-DPI scaling: set internal pixel buffer to SIZE * DPR and keep logical drawing units 0..SIZE ===> ctx.setTransform(DPR,0,0,DPR,0,0)
  const DPR = Math.max(1, window.devicePixelRatio || 1);
  canvas.width = Math.round(SIZE * DPR);
  canvas.height = Math.round(SIZE * DPR);
  // visual size will be controlled by CSS; keep aspect & rounded corners
  canvas.style.boxShadow = "0 6px 18px rgba(0,0,0,0.6)";
  canvas.style.borderRadius = "12px";
  container.appendChild(canvas);
  const ctx = canvas.getContext("2d");
  // Map drawing coordinates to logical SIZE units (so existing code that uses TILE and SIZE works unchanged).
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

  // Controls panel
  const panel = document.createElement("div");
  panel.style.color = "white";
  panel.style.marginLeft = "20px";
  panel.style.width = "320px";
  container.appendChild(panel);

  panel.innerHTML = `
    <h2 style="margin:6px 0 12px 0;color:#fff">JS Checkers — Strong AI (Mandatory-jump highlight)</h2>
    <div style="margin-bottom:10px">Turn: <span id="turn">White</span></div>
    <div style="margin-bottom:10px">Status: <span id="status">Ready</span></div>
    <div style="margin-bottom:12px">Difficulty:
      <select id="difficulty">
        <option value="3">Easy (depth 3)</option>
        <option value="5" selected>Normal (depth 5)</option>
        <option value="7">Hard (depth 7)</option>
      </select>
    </div>
    <button id="undo" style="margin-right:8px">Undo</button>
    <button id="reset">Reset</button>
    <div id="panelHelper" style="margin-top:12px;font-size:13px;color:#ddd">
      Click a piece to select it, then click a destination. Captures are forced and multi-jumps supported.
    </div>
  `;

  const turnLabel = panel.querySelector("#turn");
  const statusLabel = panel.querySelector("#status");
  const difficulty = panel.querySelector("#difficulty");
  const undoBtn = panel.querySelector("#undo");
  const resetBtn = panel.querySelector("#reset");

  // ---------- Game state ----------
  // Uppercase = human (White), lowercase = AI (Black)
  // 'R' / 'r' = man, 'K' / 'k' = king
  let board = [
    ["", "r", "", "r", "", "r", "", "r"],
    ["r", "", "r", "", "r", "", "r", ""],
    ["", "r", "", "r", "", "r", "", "r"],
    ["", "", "", "", "", "", "", ""],
    ["", "", "", "", "", "", "", ""],
    ["R", "", "R", "", "R", "", "R", ""],
    ["", "R", "", "R", "", "R", "", "R"],
    ["R", "", "R", "", "R", "", "R", ""]
  ];

  let sideToMove = 'w'; // 'w' = human (uppercase), 'b' = AI (lowercase)
  let history = []; // move history for undo
  let selected = null;
  let legalMovesCache = [];
  const tt = new Map(); // transposition table

  // ---------- Helpers ----------
  function inBounds(x,y){ return x>=0 && x<8 && y>=0 && y<8; }
  function isDarkSquare(x,y){ return (x + y) % 2 === 1; }
  function pieceColor(p){ if (!p) return null; return p === p.toUpperCase() ? 'w' : 'b'; }
  function cloneBoard(b){ return b.map(r => r.slice()); }
  function boardKey(b, side){
    return b.flat().map(s => s ? s : '.').join('') + ' ' + side;
  }

  // ---------- Drawing ----------
  function drawBoard(){
    // compute mandatory capture starts for the side to move
    const mandatoryStarts = new Set();
    const allCaps = generateAllCaptures(sideToMove, board);
    if (allCaps.length){
      for (const m of allCaps){
        mandatoryStarts.add(m.sx + "," + m.sy);
      }
    }

    // board background
    for (let y=0;y<8;y++){
      for (let x=0;x<8;x++){
        const light = (x+y) % 2 === 0;
        ctx.fillStyle = light ? "#f0d9b5" : "#8b5a2b";
        ctx.fillRect(x*(SIZE/8), y*(SIZE/8), SIZE/8, SIZE/8);
      }
    }

    // highlight mandatory pieces
    if (mandatoryStarts.size){
      for (let key of mandatoryStarts){
        const [sx, sy] = key.split(',').map(Number);
        // subtle pulsating ring
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(255,0,0,0.9)';
        ctx.lineWidth = 4;
        ctx.arc(sx*(SIZE/8) + (SIZE/8)/2, sy*(SIZE/8) + (SIZE/8)/2, (SIZE/8)*0.42, 0, Math.PI*2);
        ctx.stroke();
      }
    }

    // highlight selected and legal moves
    if (selected){
      ctx.fillStyle = "rgba(255,255,0,0.35)";
      ctx.fillRect(selected.x*(SIZE/8), selected.y*(SIZE/8), SIZE/8, SIZE/8);
      for (let m of legalMovesCache){
        if (m.sx === selected.x && m.sy === selected.y){
          // mark landing squares for that move
          const last = m.path[m.path.length - 1];
          ctx.beginPath();
          ctx.fillStyle = m.captures.length ? "rgba(255,0,0,0.45)" : "rgba(0,0,0,0.25)";
          ctx.arc(last.x*(SIZE/8) + (SIZE/8)/2, last.y*(SIZE/8) + (SIZE/8)/2, (SIZE/8)/6, 0, Math.PI*2);
          ctx.fill();
        }
      }
    }

    // draw pieces
    for (let y=0;y<8;y++){
      for (let x=0;x<8;x++){
        const p = board[y][x];
        if (!p) continue;
        const isWhite = p === p.toUpperCase();
        // piece circle
        ctx.beginPath();
        ctx.fillStyle = isWhite ? "#fff" : "#000";
        ctx.strokeStyle = "#222";
        ctx.lineWidth = 2;
        const cx = x*(SIZE/8) + (SIZE/8)/2, cy = y*(SIZE/8) + (SIZE/8)/2;
        ctx.arc(cx, cy, (SIZE/8)*0.36, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();
        // inner color for human vs ai
        ctx.beginPath();
        ctx.fillStyle = isWhite ? "#e23b3b" : "#222";
        ctx.arc(cx, cy, (SIZE/8)*0.28, 0, Math.PI*2);
        ctx.fill();
        // crown for king
        if (p.toLowerCase() === 'k'){
          ctx.fillStyle = "#ffd700";
          ctx.font = `${Math.floor((SIZE/8)*0.45)}px Arial`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("★", cx, cy+2);
        }
      }
    }

    turnLabel.textContent = sideToMove === 'w' ? 'White' : 'Black (AI)';
  }

  // ---------- Move representation ----------
  // move = { sx, sy, path:[{x,y},...], captures:[{x,y},...]} 
  function makeMoveObject(sx,sy,path,captures){
    return { sx, sy, path, captures, promotion: false };
  }

  // ---------- Move generation ----------
  // Men: white (uppercase) move up (dy = -1). Black moves down (dy = +1).
  function getAllCaptureMovesForPiece(sx,sy,bState){
    const piece = bState[sy][sx];
    if (!piece) return [];
    const color = pieceColor(piece);
    const startIsKing = piece.toLowerCase() === 'k';
    const results = [];

    function recurse(x,y, boardSoFar, path, caps, becameKing, visitedCaps){
      let foundAny = false;
      const isKingNow = startIsKing || becameKing;
      const dirs = isKingNow ? [[1,1],[1,-1],[-1,1],[-1,-1]] : (color === 'w' ? [[1,-1],[-1,-1]] : [[1,1],[-1,1]]);
      for (let [dx,dy] of dirs){
        const mx = x + dx, my = y + dy;
        const lx = x + 2*dx, ly = y + 2*dy;
        if (!inBounds(mx,my) || !inBounds(lx,ly)) continue;
        const mid = boardSoFar[my][mx];
        const land = boardSoFar[ly][lx];
        if (!mid || pieceColor(mid) === color) continue;
        if (land) continue;
        const capId = `${mx},${my}`;
        if (visitedCaps.has(capId)) continue;
        // simulate
        const nb = boardSoFar.map(r => r.slice());
        nb[my][mx] = "";
        nb[y][x] = "";
        nb[ly][lx] = piece;
        visitedCaps.add(capId);
        const newPath = path.concat([{x:lx,y:ly}]);
        const newCaps = caps.concat([{x:mx,y:my}]);
        const promoted = (piece === 'R' && ly === 0) || (piece === 'r' && ly === 7);
        recurse(lx, ly, nb, newPath, newCaps, becameKing || promoted, visitedCaps);
        visitedCaps.delete(capId);
        foundAny = true;
      }
      if (!foundAny && path.length){
        results.push(makeMoveObject(sx, sy, path, caps));
      }
      return foundAny;
    }

    recurse(sx, sy, bState.map(r => r.slice()), [], [], false, new Set());
    return results;
  }

  function generateAllCaptures(side, bState){
    let all = [];
    for (let y=0;y<8;y++){
      for (let x=0;x<8;x++){
        const p = bState[y][x];
        if (!p) continue;
        if (pieceColor(p) === (side === 'w' ? 'w' : 'b')){
          const caps = getAllCaptureMovesForPiece(x,y,bState);
          if (caps.length) all = all.concat(caps);
        }
      }
    }
    if (all.length){
      let maxCap = Math.max(...all.map(m => m.captures.length));
      all = all.filter(m => m.captures.length === maxCap);
    }
    return all;
  }

  function generateSimpleMoves(side, bState){
    const moves = [];
    for (let y=0;y<8;y++){
      for (let x=0;x<8;x++){
        const p = bState[y][x];
        if (!p) continue;
        if (pieceColor(p) !== (side === 'w' ? 'w' : 'b')) continue;
        const isKing = p.toLowerCase() === 'k';
        const dirs = isKing ? [[1,1],[1,-1],[-1,1],[-1,-1]] : (pieceColor(p) === 'w' ? [[1,-1],[-1,-1]] : [[1,1],[-1,1]]);
        for (let [dx,dy] of dirs){
          const nx = x + dx, ny = y + dy;
          if (!inBounds(nx,ny)) continue;
          if (!bState[ny][nx]) moves.push(makeMoveObject(x,y, [{x:nx,y:ny}], []));
        }
      }
    }
    return moves;
  }

  function generateLegalMovesFor(side, bState){
    const caps = generateAllCaptures(side, bState);
    if (caps.length) return caps;
    return generateSimpleMoves(side, bState);
  }

  // ---------- Make / Undo moves ----------
  function applyMove(move){
    const snapshot = { boardBefore: cloneBoard(board), sideBefore: sideToMove };
    history.push(snapshot);
    const piece = board[move.sy][move.sx];
    board[move.sy][move.sx] = "";
    for (let c of move.captures) board[c.y][c.x] = "";
    const last = move.path[move.path.length - 1];
    let placed = piece;
    if (piece === 'R' && last.y === 0) placed = 'K';
    if (piece === 'r' && last.y === 7) placed = 'k';
    board[last.y][last.x] = placed;
    sideToMove = sideToMove === 'w' ? 'b' : 'w';
  }

  function undo(){
    const snap = history.pop();
    if (!snap) return;
    board = snap.boardBefore;
    sideToMove = snap.sideBefore;
  }

  // ---------- Evaluation ----------
  const VAL = { r: 100, k: 180 };
  function evaluateBoard(b){
    let score = 0;
    for (let y=0;y<8;y++){
      for (let x=0;x<8;x++){
        const p = b[y][x];
        if (!p) continue;
        const val = VAL[p.toLowerCase()] || 0;
        const sign = p === p.toUpperCase() ? 1 : -1;
        const advancement = p === 'R' ? (7 - y) * 2 : p === 'r' ? y * 2 : 0;
        score += sign * (val + advancement);
      }
    }
    return score * (sideToMove === 'w' ? 1 : -1);
  }

  // ---------- Move ordering / Search ----------
  function moveOrderScore(m){ if (m.captures && m.captures.length) return 1000 + m.captures.length * 100; return 0; }

  function posKey(){ return boardKey(board, sideToMove); }

  let nodes = 0;
  function alphaBeta(depth, alpha, beta, maximizing){
    nodes++;
    const key = posKey() + ' ' + depth + ' ' + (maximizing ? '1' : '0');
    if (tt.has(key)) return tt.get(key);
    if (depth === 0){ const v = evaluateBoard(board); tt.set(key, v); return v; }
    const side = maximizing ? (sideToMove === 'w' ? 'w' : 'b') : (sideToMove === 'w' ? 'b' : 'w');
    let moves = generateLegalMovesFor(side, board);
    if (moves.length === 0){ const v = maximizing ? -100000 : 100000; tt.set(key, v); return v; }
    moves.sort((a,b) => moveOrderScore(b) - moveOrderScore(a));
    if (maximizing){
      let value = -Infinity;
      for (let m of moves){ applyMove(m); const val = alphaBeta(depth - 1, alpha, beta, false); undo(); if (val > value) value = val; if (val > alpha) alpha = val; if (alpha >= beta) break; }
      tt.set(key, value); return value;
    } else {
      let value = Infinity;
      for (let m of moves){ applyMove(m); const val = alphaBeta(depth - 1, alpha, beta, true); undo(); if (val < value) value = val; if (val < beta) beta = val; if (alpha >= beta) break; }
      tt.set(key, value); return value;
    }
  }

  async function aiMove(maxDepth){
    statusLabel.textContent = "AI thinking...";
    turnLabel.textContent = "Black (AI)";
    nodes = 0; tt.clear();
    let best = null;
    for (let d=1; d<=maxDepth; d++){
      let moves = generateLegalMovesFor('b', board);
      if (moves.length === 0) break;
      moves.sort((a,b) => moveOrderScore(b) - moveOrderScore(a));
      let bestVal = -Infinity;
      for (let m of moves){ applyMove(m); const v = alphaBeta(d-1, -Infinity, Infinity, true); undo(); if (v > bestVal){ bestVal = v; best = m; } }
      statusLabel.textContent = `Searched depth ${d} — nodes ${nodes} — best ${bestVal}`;
      await new Promise(r => setTimeout(r, 20));
    }
    if (best){ applyMove(best); drawBoard(); statusLabel.textContent = "AI moved"; }
    else statusLabel.textContent = "AI has no moves";
  }

  // ---------- Game end detection ----------
  function gameStatus(){ const moves = generateLegalMovesFor(sideToMove === 'w' ? 'w' : 'b', board); if (moves.length === 0){ const winner = sideToMove === 'w' ? 'Black (AI)' : 'White'; return { result: 'ended', winner }; } return { result: 'playing' }; }

  // ---------- Pointer handling helpers (works for mouse & touch & scaled canvas) ----------
  // Convert clientX/Y to the logical canvas coordinate space 0..SIZE (we keep drawing coordinates in that space).
  function clientToCanvas(clientX, clientY){
    const rect = canvas.getBoundingClientRect();
    // logical drawing space width is SIZE (not canvas.width which is SIZE * DPR)
    const scaleX = SIZE / rect.width;
    const scaleY = SIZE / rect.height;
    const cx = (clientX - rect.left) * scaleX;
    const cy = (clientY - rect.top) * scaleY;
    return { cx, cy };
  }

  // Centralized pointer handler that uses the same logic as your original onclick, but receives client coords.
  async function handlePointer(clientX, clientY){
    if (sideToMove !== 'w') return; // human is white only here
    const { cx, cy } = clientToCanvas(clientX, clientY);
    const x = Math.floor(cx / TILE), y = Math.floor(cy / TILE);
    if (!inBounds(x,y) || !isDarkSquare(x,y)) return;

    const p = board[y][x];

    // compute mandatory capture starts
    const allCaps = generateAllCaptures(sideToMove, board);
    const mandatoryStarts = new Set(allCaps.map(m => m.sx + "," + m.sy));

    if (!selected){
      if (p && pieceColor(p) === 'w'){
        // if mandatory captures exist, only allow selecting those pieces
        if (mandatoryStarts.size && !mandatoryStarts.has(x+","+y)) return;
        selected = { x, y };
        legalMovesCache = generateLegalMovesFor('w', board);
      }
    } else {
      const all = generateLegalMovesFor('w', board);
      const candidate = all.find(m => m.sx === selected.x && m.sy === selected.y && m.path[m.path.length - 1].x === x && m.path[m.path.length - 1].y === y);
      if (candidate){
        applyMove(candidate);
        selected = null; legalMovesCache = [];
        drawBoard();
        const st = gameStatus();
        if (st.result === 'playing'){
          sideToMove = 'b'; turnLabel.textContent = 'Black (AI)';
          await aiMove(Number(difficulty.value));
          const st2 = gameStatus();
          if (st2.result === 'ended') statusLabel.textContent = `Game over — ${st2.winner} wins`;
          else statusLabel.textContent = 'Your move';
        } else {
          statusLabel.textContent = `Game over — ${st.winner} wins`;
        }
      } else {
        if (p && pieceColor(p) === 'w'){
          if (mandatoryStarts.size && !mandatoryStarts.has(x+","+y)){ selected = null; legalMovesCache = []; return; }
          selected = { x, y };
          legalMovesCache = generateLegalMovesFor('w', board);
        } else { selected = null; legalMovesCache = []; }
      }
    }
    drawBoard();
  }

  // Wire mouse click to centralized handler
  canvas.addEventListener('click', (ev) => {
    // left-click maps to clientX/Y
    handlePointer(ev.clientX, ev.clientY);
  }, { passive: true });

  // Wire touch -> use first touch, prevent default to avoid page scroll while playing
  canvas.addEventListener('touchstart', (ev) => {
    ev.preventDefault();
    if (ev.touches && ev.touches.length){
      const t = ev.touches[0];
      handlePointer(t.clientX, t.clientY);
    }
  }, { passive: false });

  // Also handle pointerdown for stylus / pointer devices
  canvas.addEventListener('pointerdown', (ev) => {
    // avoid duplicate calls if pointer triggers click too; allow pointer only for primary button/touch
    if (ev.pointerType === 'mouse' && ev.button !== 0) return;
    handlePointer(ev.clientX, ev.clientY);
  }, { passive: true });

  // Redraw on resize so board stays crisp and highlights align after CSS driven visual scaling.
  window.addEventListener('resize', () => {
    // adjust canvas style width is controlled by CSS but we must redraw at new visual size
    drawBoard();
  });

  // ---------- Click handling (original behavior moved into handlePointer) ----------
  // (original onclick logic preserved inside handlePointer)

  undoBtn.onclick = () => { undo(); if (history.length) undo(); selected = null; legalMovesCache = []; drawBoard(); statusLabel.textContent = "Undone"; };

  resetBtn.onclick = () => {
    board = [
      ["", "r", "", "r", "", "r", "", "r"],
      ["r", "", "r", "", "r", "", "r", ""],
      ["", "r", "", "r", "", "r", "", "r"],
      ["", "", "", "", "", "", "", ""],
      ["", "", "", "", "", "", "", ""],
      ["R", "", "R", "", "R", "", "R", ""],
      ["", "R", "", "R", "", "R", "", "R"],
      ["R", "", "R", "", "R", "", "R", ""]
    ];
    sideToMove = 'w'; history = []; selected = null; legalMovesCache = []; tt.clear(); drawBoard(); statusLabel.textContent = "Reset";
  };

  // ---------- Start ----------
  // ensure canvas CSS visual size (the CSS in <head> controls it), we just need to draw using logical SIZE units.
  drawBoard(); statusLabel.textContent = "Ready";
})();
  </script>
</body>
</html>
