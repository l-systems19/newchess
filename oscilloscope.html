<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>OscilloSim Mobile-Ready — Fixed</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap" rel="stylesheet">
  <style>
    :root{--bg:#041428;--panel:#0b1220;--muted:#9fb2ce;--accent:#4ee3a1;--accent2:#27c0ff}
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial,sans-serif;background:linear-gradient(180deg,#031022 0%, #071426 60%);color:#e6eef8;-webkit-font-smoothing:antialiased}

    header{display:flex;align-items:center;justify-content:space-between;padding:12px 16px}
    .brand{display:flex;align-items:center;gap:12px}
    .logo{width:44px;height:44px;border-radius:10px;background:linear-gradient(135deg,#3ee7b5,#3aa6ff);display:flex;align-items:center;justify-content:center;font-weight:800;color:#042}
    .top-menu{display:flex;gap:8px}
    .menu-btn{background:rgba(255,255,255,0.02);padding:6px 10px;border-radius:10px;font-weight:600;color:var(--muted);border:1px solid rgba(255,255,255,0.03)}

    .app{display:flex;gap:12px;padding:12px;max-width:1200px;margin:0 auto}
    .left{flex:1;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:12px;min-height:360px}
    .right{width:360px;min-width:220px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border-radius:12px;padding:12px;display:flex;flex-direction:column;gap:10px}

    .scope-top{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}

    /* make canvas responsive and mobile-friendly */
    .canvas-wrap{position:relative;width:100%;}
    canvas{display:block;width:100%;height:auto;border-radius:10px;background:linear-gradient(180deg,#07162a,#021026);box-shadow:inset 0 2px 18px rgba(0,0,0,0.55);border:1px solid rgba(255,255,255,0.03);touch-action:none}

    .panel{background:transparent;border-radius:10px;padding:10px;border:1px solid rgba(255,255,255,0.02)}
    .control-group{display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center;margin:8px 0}
    .range{width:100%}
    input[type=range]{-webkit-appearance:none;height:8px;border-radius:6px;background:linear-gradient(90deg,#283241,#091220);outline:none}
    input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:16px;height:16px;border-radius:50%;background:var(--accent);box-shadow:0 2px 8px rgba(78,227,161,0.15)}
    .btn{padding:8px 10px;border-radius:10px;border:none;background:rgba(255,255,255,0.04);color:var(--muted);font-weight:600}
    .btn.primary{background:linear-gradient(90deg,var(--accent),var(--accent2));color:#042}
    .chip{padding:6px 10px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.02);font-weight:600;color:var(--muted);cursor:pointer}
    .chip.active{background:rgba(78,227,161,0.12);color:var(--accent);border-color:rgba(78,227,161,0.12)}
    .small{font-size:12px;color:var(--muted)}

    @media (max-width:980px){.app{flex-direction:column}.right{width:100%}}
    @media (max-width:520px){header{padding:10px}.logo{width:40px;height:40px}}
  </style>
</head>
<body>
  <header>
    <div class="brand"><div class="logo">OS</div><div><div style="font-weight:800">OscilloSim — Mobile Ready</div><div class="small">Fixed canvas, high-DPI & responsive</div></div></div>
    <div class="top-menu"><button class="menu-btn">File</button><button class="menu-btn">Help</button></div>
  </header>

  <main class="app">
    <section class="left">
      <div class="scope-top">
        <div><div style="font-weight:700">Oscilloscope</div><div class="small">Time/div: <span id="timebaseLabel">5 ms/div</span> · SR: <span id="srLabel">100 kS/s</span></div></div>
        <div style="display:flex;gap:8px"><button class="btn" id="runBtn">Running</button><button class="btn" id="singleBtn">Single</button><button class="btn" id="snapBtn">PNG</button><button class="btn" id="csvBtn">CSV</button></div>
      </div>

      <div class="canvas-wrap">
        <canvas id="scopeCanvas" aria-label="Oscilloscope display"></canvas>
      </div>

      <div style="display:flex;gap:10px;margin-top:10px;flex-wrap:wrap">
        <div class="panel" style="flex:1;min-width:200px"><div class="small">Measurements</div><div style="display:flex;gap:8px;margin-top:8px"><div class="chip">RMS</div><div class="chip">Freq</div><div class="chip">Vpp</div></div></div>
        <div class="panel" style="width:220px;min-width:160px"><div class="small">Display</div><div style="display:flex;gap:8px;margin-top:8px"><div class="chip active" id="gridToggle">Grid</div><div class="chip" id="persistenceToggle">Persistence</div><div class="chip" id="xyToggle">XY</div></div></div>
      </div>
    </section>

    <aside class="right">
      <div style="display:flex;justify-content:space-between;align-items:center"><div style="font-weight:700">Controls</div><div class="small">Mobile & Desktop</div></div>

      <div class="panel">
        <div class="small">Channel 1</div>
        <div class="control-group"><label>Enable</label><input type="checkbox" id="ch1Enable" checked></div>
        <div class="control-group"><label>Wave</label><select id="ch1Wave"><option value="sine">sine</option><option value="square">square</option><option value="triangle">triangle</option><option value="saw">saw</option><option value="noise">noise</option></select></div>
        <div class="control-group"><label>Freq (Hz)</label><input id="ch1Freq" type="range" min="0.5" max="20000" value="440" class="range"><div class="small" id="ch1FreqVal">440</div></div>
        <div class="control-group"><label>Amplitude (V)</label><input id="ch1Amp" type="range" min="0.01" max="12" step="0.01" value="1" class="range"><div class="small" id="ch1AmpVal">1.00</div></div>
        <div class="control-group"><label>Offset (V)</label><input id="ch1Offset" type="range" min="-6" max="6" step="0.01" value="0" class="range"><div class="small" id="ch1OffVal">0.00</div></div>
      </div>

      <div class="panel">
        <div class="small">Channel 2</div>
        <div class="control-group"><label>Enable</label><input type="checkbox" id="ch2Enable" checked></div>
        <div class="control-group"><label>Wave</label><select id="ch2Wave"><option value="sine">sine</option><option value="square">square</option><option value="triangle">triangle</option><option value="saw">saw</option><option value="noise">noise</option></select></div>
        <div class="control-group"><label>Freq (Hz)</label><input id="ch2Freq" type="range" min="0.5" max="20000" value="660" class="range"><div class="small" id="ch2FreqVal">660</div></div>
        <div class="control-group"><label>Amplitude (V)</label><input id="ch2Amp" type="range" min="0.01" max="12" step="0.01" value="0.8" class="range"><div class="small" id="ch2AmpVal">0.80</div></div>
        <div class="control-group"><label>Offset (V)</label><input id="ch2Offset" type="range" min="-6" max="6" step="0.01" value="0" class="range"><div class="small" id="ch2OffVal">0.00</div></div>
      </div>

      <div class="panel">
        <div class="small">Timebase & Trigger</div>
        <div class="control-group"><label>Time/div (ms)</label><input id="timebase" type="range" min="0.01" max="100" step="0.01" value="5" class="range"></div>
        <div class="control-group"><label>Sample Rate (kS/s)</label><input id="sampleRate" type="range" min="1" max="5000" value="100" class="range"><div class="small" id="srVal">100</div></div>
        <div class="control-group"><label>Trigger Level (V)</label><input id="triggerLevel" type="range" min="-6" max="6" step="0.01" value="0" class="range"></div>
        <div class="control-group"><label>Trigger Mode</label><select id="triggerMode"><option value="auto">Auto</option><option value="normal">Normal</option><option value="single">Single</option></select></div>
        <div class="control-group"><label>Edge</label><select id="triggerEdge"><option value="rising">Rising</option><option value="falling">Falling</option></select></div>
      </div>

      <div class="panel">
        <div class="small">Display</div>
        <div class="control-group"><label>Grid Lines</label><input id="gridLines" type="range" min="4" max="20" step="1" value="10" class="range"></div>
        <div class="control-group"><label>Brightness</label><input id="brightness" type="range" min="0.3" max="1.8" step="0.01" value="1" class="range"></div>
        <div style="display:flex;gap:8px;margin-top:8px"><button class="btn primary" id="fftBtn">FFT</button><button class="btn" id="autozBtn">AutoScale</button></div>
      </div>
    </aside>
  </main>

  <footer style="padding:8px 16px;color:var(--muted);text-align:center">OscilloSim — Mobile fixed • Responsive • High DPI</footer>

  <script>
  // Mobile-friendly, robust oscilloscope simulator
  (function(){
    // helpers
    const $ = id => document.getElementById(id);
    const canvas = $('scopeCanvas');
    const ctx = canvas.getContext && canvas.getContext('2d');
    if(!ctx){ document.body.innerHTML = '<p style="padding:20px;color:#fff">Canvas not supported in this browser.</p>'; return; }

    // UI elements
    const ui = {
      ch1Enable: $('ch1Enable'), ch1Wave:$('ch1Wave'), ch1Freq:$('ch1Freq'), ch1Amp:$('ch1Amp'), ch1Offset:$('ch1Offset'),
      ch2Enable: $('ch2Enable'), ch2Wave:$('ch2Wave'), ch2Freq:$('ch2Freq'), ch2Amp:$('ch2Amp'), ch2Offset:$('ch2Offset'),
      timebase: $('timebase'), sampleRate: $('sampleRate'), triggerLevel: $('triggerLevel'), triggerMode: $('triggerMode'), triggerEdge: $('triggerEdge'),
      gridToggle: $('gridToggle'), persistenceToggle: $('persistenceToggle'), xyToggle: $('xyToggle'), gridLines: $('gridLines'), brightness: $('brightness'),
      runBtn: $('runBtn'), singleBtn: $('singleBtn'), snapBtn: $('snapBtn'), csvBtn: $('csvBtn'), fftBtn: $('fftBtn'), autozBtn: $('autozBtn'),
      ch1FreqVal: $('ch1FreqVal'), ch1AmpVal: $('ch1AmpVal'), ch1OffVal: $('ch1OffVal'), ch2FreqVal: $('ch2FreqVal'), ch2AmpVal: $('ch2AmpVal'), ch2OffVal: $('ch2OffVal'),
      timebaseLabel: $('timebaseLabel'), srLabel: $('srLabel'), srVal: $('srVal')
    };

    // state
    let DPR = Math.max(1, window.devicePixelRatio || 1);
    let running = true, persistence=false, gridOn=true, xyMode=false, capturedData=null;
    let lastResize = 0;

    // ensure CSS height for canvas (half aspect ratio) for mobile initially
    function ensureCSSHeight(){
      // If user didn't set explicit height, compute a sensible height from width
      const rect = canvas.getBoundingClientRect();
      if(rect.width && (!canvas.style.height || canvas.style.height==='')){
        const h = Math.max(240, Math.round(rect.width * 0.55));
        canvas.style.height = h + 'px';
      }
    }
    ensureCSSHeight();

    // Resize handling using ResizeObserver for robustness on mobile
    const resizeCanvas = ()=>{
      DPR = Math.max(1, window.devicePixelRatio || 1);
      // ensure CSS height before measuring
      ensureCSSHeight();
      const rect = canvas.getBoundingClientRect();
      const cssW = Math.max(1, Math.round(rect.width));
      const cssH = Math.max(1, Math.round(rect.height));
      // set actual pixel size
      canvas.width = Math.max(1, Math.floor(cssW * DPR));
      canvas.height = Math.max(1, Math.floor(cssH * DPR));
      // map drawing to CSS pixels
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    };

    // use ResizeObserver on the canvas wrapper to detect layout changes reliably
    try{
      const ro = new ResizeObserver(entries=>{ if(entries && entries.length) { resizeCanvas(); lastResize = Date.now(); } });
      ro.observe(canvas);
      window.addEventListener('orientationchange', ()=>{ setTimeout(resizeCanvas, 120); });
      window.addEventListener('resize', ()=>{ setTimeout(resizeCanvas, 60); });
    } catch(e){ window.addEventListener('resize', resizeCanvas); }

    // waveform generator factory
    function makeWave(type, freq, amp, offset, phase=0){
      const twoPi = Math.PI*2;
      return t => {
        const p = (t*freq + phase) % 1;
        switch(type){
          case 'sine': return Math.sin(twoPi*p)*amp + offset;
          case 'square': return (p<0.5?1:-1)*amp + offset;
          case 'triangle': return ((Math.abs((p*2)-1)*2)-1)*amp + offset;
          case 'saw': return ((p*2)-1)*amp + offset;
          case 'noise': return (Math.random()*2-1)*amp + offset;
          default: return 0;
        }
      }
    }

    // simple radix-2 FFT (same as before)
    function fftReal(input){
      const N = input.length; if((N & (N-1)) !== 0) throw new Error('FFT input length must be power of two');
      const Re = new Float32Array(N); const Im = new Float32Array(N);
      for(let i=0;i<N;i++) Re[i]=input[i];
      const bits = Math.log2(N)|0;
      for(let i=0;i<N;i++){ let j=0,x=i; for(let k=0;k<bits;k++){ j=(j<<1)|(x&1); x>>=1; } if(j>i){ let tr=Re[i]; Re[i]=Re[j]; Re[j]=tr; let ti=Im[i]; Im[i]=Im[j]; Im[j]=ti; } }
      for(let len=2; len<=N; len<<=1){ const ang = -2*Math.PI/len; const wlenRe=Math.cos(ang), wlenIm=Math.sin(ang); for(let i=0;i<N;i+=len){ let uRe=1,uIm=0; for(let j=0;j<len/2;j++){ const aRe=Re[i+j], aIm=Im[i+j]; const bRe=Re[i+j+len/2]*uRe - Im[i+j+len/2]*uIm; const bIm=Re[i+j+len/2]*uIm + Im[i+j+len/2]*uRe; Re[i+j]=aRe+bRe; Im[i+j]=aIm+bIm; Re[i+j+len/2]=aRe-bRe; Im[i+j+len/2]=aIm-bIm; const tmpRe=uRe*wlenRe - uIm*wlenIm; uIm = uRe*wlenIm + uIm*wlenRe; uRe = tmpRe; } } }
      const mag = new Float32Array(N/2); for(let i=0;i<N/2;i++) mag[i] = Math.hypot(Re[i], Im[i]); return mag;
    }

    // trigger finder
    function findTriggerIndex(samples, level, edge){ for(let i=1;i<samples.length;i++){ if(edge==='rising' && samples[i-1]<level && samples[i]>=level) return i; if(edge==='falling' && samples[i-1]>level && samples[i]<=level) return i; } return -1; }

    // drawing helpers (CSS pixels)
    function drawGrid(cssW, cssH, lines, bright){ ctx.save(); ctx.fillStyle='#021426'; ctx.fillRect(0,0,cssW,cssH); if(!gridOn){ ctx.restore(); return; } const gx=cssW/lines, gy=cssH/lines; ctx.lineWidth=1; for(let i=0;i<=lines;i++){ const x=Math.round(i*gx)+0.5; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,cssH); ctx.strokeStyle='rgba(255,255,255,'+(0.03*bright)+')'; ctx.stroke(); } for(let j=0;j<=lines;j++){ const y=Math.round(j*gy)+0.5; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(cssW,y); ctx.strokeStyle='rgba(255,255,255,'+(0.02*bright)+')'; ctx.stroke(); } ctx.restore(); }

    function drawTrace(samples, color, cssW, cssH, vscale, voffset, thickness=2){ if(!samples || samples.length===0) return; ctx.save(); ctx.lineWidth = thickness; ctx.strokeStyle = color; ctx.beginPath(); const L=samples.length; for(let i=0;i<L;i++){ const x=(i/(L-1))*cssW; const y=(cssH/2)-((samples[i]-voffset)*vscale); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); } ctx.stroke(); ctx.restore(); }

    // UI label updates
    function updateUILabels(){ ui.ch1FreqVal.textContent = Number(ui.ch1Freq.value).toFixed(2); ui.ch1AmpVal.textContent = Number(ui.ch1Amp.value).toFixed(2); ui.ch1OffVal.textContent = Number(ui.ch1Offset.value).toFixed(2); ui.ch2FreqVal.textContent = Number(ui.ch2Freq.value).toFixed(2); ui.ch2AmpVal.textContent = Number(ui.ch2Amp.value).toFixed(2); ui.ch2OffVal.textContent = Number(ui.ch2Offset.value).toFixed(2); ui.timebaseLabel.textContent = Number(ui.timebase.value) + ' ms/div'; ui.srLabel.textContent = Number(ui.sampleRate.value) + ' kS/s'; if(ui.srVal) ui.srVal.textContent = Number(ui.sampleRate.value); }
    updateUILabels();

    // main renderer
    let prevFrame1=null, prevFrame2=null;
    let lastRender = 0;
    function render(now){
      if(!now) now = performance.now();
      // avoid rendering too frequently on slow devices
      if(now - lastRender < 16) { if(running) requestAnimationFrame(render); return; }
      lastRender = now;
      resizeCanvas();
      const cssW = canvas.clientWidth, cssH = canvas.clientHeight;
      // compute sample count
      const msPerDiv = Math.max(0.00001, Number(ui.timebase.value));
      const totalSec = (msPerDiv/1000)*10;
      const sr = Math.max(1, Number(ui.sampleRate.value)) * 1000;
      let desired = Math.floor(totalSec * sr);
      desired = Math.max(256, Math.min(desired, 65536));
      let N=1; while(N<desired) N<<=1; if(N>65536) N=65536;
      const dt = totalSec / N;

      // generators
      const g1 = makeWave(ui.ch1Wave.value, Number(ui.ch1Freq.value), Number(ui.ch1Amp.value), Number(ui.ch1Offset.value));
      const g2 = makeWave(ui.ch2Wave.value, Number(ui.ch2Freq.value), Number(ui.ch2Amp.value), Number(ui.ch2Offset.value));

      // fill buffers
      const buf1 = new Float32Array(N), buf2 = new Float32Array(N);
      for(let i=0;i<N;i++){ const t = i*dt; buf1[i] = ui.ch1Enable.checked ? g1(t) : 0; buf2[i] = ui.ch2Enable.checked ? g2(t) : 0; }

      // trigger handling
      const trigLevel = Number(ui.triggerLevel.value); const edge = ui.triggerEdge.value;
      let triggerIndex = findTriggerIndex(buf1, trigLevel, edge);
      if(ui.triggerMode.value==='auto' && triggerIndex===-1) triggerIndex = Math.floor(N/4);
      if(ui.triggerMode.value==='normal' && triggerIndex===-1) triggerIndex = Math.floor(N/4);
      if(ui.triggerMode.value==='single' && triggerIndex===-1) triggerIndex = Math.floor(N/4);

      // display window
      const displayPoints = Math.min(2048, Math.max(256, Math.floor(cssW)));
      const halfWindow = Math.floor(displayPoints*0.25);
      const start = Math.max(0, triggerIndex - halfWindow);
      const end = Math.min(N, start + displayPoints);
      const len = end - start;
      const disp1 = new Float32Array(len), disp2 = new Float32Array(len);
      for(let i=0;i<len;i++){ disp1[i] = buf1[start+i]; disp2[i] = buf2[start+i]; }
      capturedData = {dt:dt, samples:len, ch1:disp1, ch2:disp2};

      // draw grid
      drawGrid(cssW, cssH, Number(ui.gridLines.value) || 10, Number(ui.brightness.value) || 1);

      // persistence
      if(persistence && prevFrame1 && prevFrame2){ ctx.save(); ctx.globalAlpha = 0.18; if(ui.ch1Enable.checked) drawTrace(prevFrame1,'rgba(78,227,161,0.6)',cssW,cssH,(cssH/2)/5,0,1); if(ui.ch2Enable.checked) drawTrace(prevFrame2,'rgba(40,160,255,0.6)',cssW,cssH,(cssH/2)/5,0,1); ctx.restore(); }

      // draw traces or XY
      if(!xyMode){ if(ui.ch1Enable.checked) drawTrace(disp1,'#4ee3a1',cssW,cssH,(cssH/2)/5,0,2); if(ui.ch2Enable.checked) drawTrace(disp2,'#27c0ff',cssW,cssH,(cssH/2)/5,0,2); }
      else { ctx.save(); ctx.lineWidth=2; ctx.strokeStyle='#ffd66b'; ctx.beginPath(); const L=Math.min(disp1.length, disp2.length); for(let i=0;i<L;i++){ const x=(disp1[i]/5)*cssW*0.5 + cssW*0.5; const y=cssH*0.5 - (disp2[i]/5)*cssH*0.5; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); } ctx.stroke(); ctx.restore(); }

      prevFrame1 = disp1.slice(0); prevFrame2 = disp2.slice(0);

      // overlays
      ctx.save(); ctx.font = '12px Inter, Arial'; ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.fillText('Time/div: '+ui.timebase.value+' ms/div', 8, 14); ctx.fillText('SR: '+ui.sampleRate.value+' kS/s', 8, 32); ctx.fillText('Trig: '+ui.triggerLevel.value+' V ('+ui.triggerEdge.value+')', 8, 50); ctx.restore();

      if(running) requestAnimationFrame(render);
    }

    // export CSV
    function exportCSV(){ if(!capturedData){ alert('No capture yet — run the scope'); return; } let csv='time(s),ch1(V),ch2(V)
'; for(let i=0;i<capturedData.samples;i++){ csv += (i*capturedData.dt).toFixed(9)+','+capturedData.ch1[i].toFixed(6)+','+capturedData.ch2[i].toFixed(6)+'
'; } const blob=new Blob([csv],{type:'text/csv'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='capture.csv'; a.click(); URL.revokeObjectURL(url); }

    // PNG export
    function exportPNG(){ try{ const link=document.createElement('a'); link.download='oscilloscope.png'; link.href = canvas.toDataURL('image/png'); link.click(); }catch(e){ alert('PNG export failed: '+e.message); } }

    // FFT display
    function doFFT(){ if(!capturedData){ alert('No capture for FFT'); return; } let N=1; while(N<capturedData.samples) N<<=1; const arr=new Float32Array(N); arr.set(capturedData.ch1.subarray(0, capturedData.samples)); try{ const mag=fftReal(arr); let peakIdx=1, peakVal=mag[1]; for(let i=2;i<mag.length;i++){ if(mag[i]>peakVal){ peakVal=mag[i]; peakIdx=i; } } const freqRes = 1 / (capturedData.dt * N); const peakFreq = peakIdx * freqRes; alert('FFT peak: '+peakFreq.toFixed(2)+' Hz'); }catch(e){ alert('FFT error: '+e.message); } }

    // UI bindings
    ['input','change'].forEach(ev=>{ [ui.ch1Freq,ui.ch1Amp,ui.ch1Offset,ui.ch2Freq,ui.ch2Amp,ui.ch2Offset,ui.timebase,ui.sampleRate,ui.triggerLevel,ui.gridLines,ui.brightness].forEach(el=>el.addEventListener(ev, updateUILabels)); });

    ui.gridToggle.addEventListener('click', ()=>{ gridOn = !gridOn; ui.gridToggle.classList.toggle('active'); ui.gridToggle.textContent = gridOn? 'Grid':'No Grid'; });
    ui.persistenceToggle.addEventListener('click', ()=>{ persistence = !persistence; ui.persistenceToggle.classList.toggle('active'); ui.persistenceToggle.textContent = persistence? 'Persistence On':'Persistence'; });
    ui.xyToggle.addEventListener('click', ()=>{ xyMode = !xyMode; ui.xyToggle.classList.toggle('active'); ui.xyToggle.textContent = xyMode? 'XY':'XY'; });

    ui.runBtn.addEventListener('click', ()=>{ running = !running; ui.runBtn.textContent = running? 'Running':'Stopped'; if(running) requestAnimationFrame(render); });
    ui.singleBtn.addEventListener('click', ()=>{ running=false; ui.runBtn.textContent='Stopped'; render(); });
    ui.snapBtn.addEventListener('click', exportPNG); ui.csvBtn.addEventListener('click', exportCSV); ui.fftBtn.addEventListener('click', doFFT);
    ui.autozBtn.addEventListener('click', ()=>{ if(!capturedData){ alert('Capture first'); return; } const mx1=Math.max(...capturedData.ch1.map(Math.abs)), mx2=Math.max(...capturedData.ch2.map(Math.abs)); if(mx1>0) ui.ch1Amp.value = (Number(ui.ch1Amp.value) * (3/mx1)).toFixed(2); if(mx2>0) ui.ch2Amp.value = (Number(ui.ch2Amp.value) * (3/mx2)).toFixed(2); updateUILabels(); });

    // start rendering once the user interacts (some mobile browsers require gesture for animation), but to keep it simple start immediately
    requestAnimationFrame(render);

    // visibility handling to save CPU
    document.addEventListener('visibilitychange', ()=>{ if(document.hidden) running=false; else { running=true; requestAnimationFrame(render); } });

    // ensure first resize after load (some mobile browsers report 0 initially)
    window.addEventListener('load', ()=>{ setTimeout(()=>{ resizeCanvas(); requestAnimationFrame(render); }, 60); });

  })();
  </script>
</body>
</html>
