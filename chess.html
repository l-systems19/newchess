<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="theme-color" content="#071226" />
  <title>Responsive JS Chess — Mobile & Desktop Friendly (Mobile Fix)</title>
  <style>
    :root{
      --bg1:#0f1724;
      --bg2:#071226;
      --accent:#ffd166;
      --panel-bg:rgba(255,255,255,0.06);
      --glass: rgba(255,255,255,0.04);
      --soft: rgba(255,255,255,0.06);
      --text:#e6eef8;
      --muted:#b8c6d9;
      --danger: rgba(255,60,60,0.12);
      --danger-strong: rgba(255,40,40,0.18);
      --max-content-width:1200px;
      --board-max:640px;
      --ui-gap:20px;
      --panel-width-desktop:320px;
      --safe-pad: max(env(safe-area-inset-left,0px), 12px);
    }

    /* base */
    html,body{height:100%;}
    body{
      margin:0;
      min-height:100%;
      font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: radial-gradient(1200px 600px at 10% 10%, rgba(255,255,255,0.02), transparent),
                  linear-gradient(180deg,var(--bg1), var(--bg2));
      color:var(--text);
      display:flex;
      align-items:flex-start;
      justify-content:center;
      padding:calc(var(--safe-pad) + 8px);
      box-sizing:border-box;
      transition: background 240ms ease, color 200ms ease;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* container */
    .wrap{
      width:100%;
      max-width:var(--max-content-width);
      display:flex;
      gap:var(--ui-gap);
      align-items:flex-start;
      justify-content:center;
      flex-wrap:nowrap;
      box-sizing:border-box;
      padding:12px;
    }

    /* board area */
    .board-wrap{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));
      border-radius:14px;
      padding:14px;
      box-shadow: 0 14px 40px rgba(2,6,23,0.6);
      display:flex;
      align-items:center;
      justify-content:center;
      width: min(var(--board-max), 66vw);
      aspect-ratio: 1/1; /* keep square container for canvas */
      transition: box-shadow 200ms ease, border 200ms ease, transform 200ms ease;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }

    /* subtle hover/lift on desktop */
    @media (hover:hover) and (pointer:fine) {
      .board-wrap:hover{ transform: translateY(-6px); box-shadow: 0 20px 50px rgba(2,6,23,0.72); }
    }

    canvas{
      width:100%;
      height:100%;
      display:block;
      border-radius:10px;
      touch-action:none; /* we handle pointer events */
      cursor:grab;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02));
      box-sizing:border-box;
    }
    canvas:active{ cursor:grabbing; }
    canvas:focus{ outline: 3px solid rgba(255,209,102,0.12); outline-offset:4px; }

    /* control panel */
    .panel{
      width:var(--panel-width-desktop);
      max-width:92vw;
      background:var(--panel-bg);
      border-radius:14px;
      padding:16px;
      box-sizing:border-box;
      backdrop-filter: blur(6px) saturate(120%);
      display:flex;
      flex-direction:column;
      gap:12px;
      align-self:flex-start;
      transition: border 200ms ease, transform 200ms ease, background 200ms ease, box-shadow 200ms ease, max-height 240ms ease;
      border: 1px solid rgba(255,255,255,0.03);
      box-shadow: 0 8px 26px rgba(2,6,23,0.45);
    }

    .panel h2{
      margin:0;
      font-size:18px;
      letter-spacing:0.2px;
    }

    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    label{font-size:13px;color:#cfe8ff; min-width:68px}
    .muted{color:var(--muted);font-size:14px}
    select, button{
      padding:10px 12px;
      border-radius:10px;
      border:0;
      background:var(--glass);
      color:var(--text);
      font-size:15px;
      min-height:40px;
      box-shadow: inset 0 -2px 0 rgba(0,0,0,0.12);
      -webkit-appearance:none;
      appearance:none;
    }
    select{ padding-right: 28px; }
    button{ cursor:pointer; transition: transform 120ms ease, box-shadow 120ms ease; }
    button:active{ transform: translateY(1px); }
    button:focus{ outline: 2px solid rgba(255,209,102,0.15); outline-offset:3px; }

    .controls{display:flex;gap:8px}
    .controls button{ flex:1; min-width:100px; }

    .footer{font-size:13px;color:var(--muted);margin-top:6px}

    /* AI thinking visual state: FULL BACKGROUND RED */
    .ai-thinking{
      background: linear-gradient(180deg, rgba(255,40,40,0.98), rgba(180,10,10,0.98));
      color: #fff;
    }
    .ai-thinking .board-wrap{ box-shadow: 0 0 0 8px rgba(255,40,40,0.14), inset 0 0 30px rgba(255,0,0,0.03); }
    .ai-thinking .panel{ background: rgba(255, 255, 255, 0.04); border: 1px solid rgba(255,255,255,0.12); box-shadow: 0 10px 30px rgba(255,20,20,0.06); }

    /* responsive: stack on small screens, panel fixed at bottom for reachability */
    @media (max-width:880px){
      .wrap{flex-direction:column;align-items:center;gap:12px;padding-bottom:88px}

      /* hidden checkbox to control collapsed/expanded mobile panel (CSS-only) */
      #mobilePanelToggle{ display:none; }

      /* label toggle */
      .panel-toggle{
        position:fixed;
        left:50%;
        bottom:12px;
        transform:translateX(-50%);
        z-index:130;
        display:flex;
        align-items:center;
        justify-content:center;
        width:56px;
        height:56px;
        border-radius:999px;
        background:var(--glass);
        color:var(--text);
        font-size:18px;
        box-shadow: 0 8px 20px rgba(2,6,23,0.5);
        border:1px solid rgba(255,255,255,0.04);
      }

      .panel-toggle svg{ transform:rotate(0deg); transition: transform 200ms ease; }

      /* the panel sits above the board but we limit its height when collapsed */
      .panel{
        position:fixed;
        left:50%;
        bottom:12px;
        transform:translateX(-50%);
        width:calc(100% - 24px);
        display:flex;
        flex-direction:column;
        align-items:center;
        justify-content:flex-start;
        padding:10px 12px 12px 12px;
        gap:8px;
        border-radius:16px;
        z-index:120;
        box-shadow: 0 12px 40px rgba(2,6,23,0.7);
        max-height:76px; /* collapsed height: show a compact row */
        overflow:hidden;
      }

      /* when toggle is checked -> expand panel and rotate chevron */
      #mobilePanelToggle:checked + .panel{ max-height:320px; }
      #mobilePanelToggle:checked + .panel + .panel-toggle{ transform: translateX(-50%) rotate(180deg); }

      .panel h2{display:none} /* save space on mobile */
      .row{align-items:center}
      .board-wrap{ width: min(92vw, var(--board-max)); aspect-ratio:1/1; padding:10px; border-radius:12px; }
      select, button{padding:12px 14px; font-size:16px; min-height:46px}
      .footer{ display:none }
      .controls button{ min-width:90px; padding:12px 14px; border-radius:12px }

      /* show a compact inline row for the collapsed panel (we keep elements but hide some via opacity) */
      .panel .muted{ font-size:13px; }
      .panel .row{ width:100%; justify-content:space-between }
      .panel .controls{ width:100%; }

      /* when collapsed, hide verbose controls visually to avoid covering most of the board */
      #mobilePanelToggle:not(:checked) .controls{ opacity:0; transform: translateY(6px); pointer-events:none; height:0; }
      #mobilePanelToggle:not(:checked) select{ opacity:0; pointer-events:none; height:0; }

      /* better board sizing for narrow tall phones: allow board to use most of viewport height */
      .board-wrap{
        max-height: calc(100vh - 120px);
      }

      /* ensure the toggle sits visually above the panel */
      .panel-toggle{ bottom:86px; }
      #mobilePanelToggle:checked + .panel + .panel-toggle{ bottom:12px; }

    }

    /* higher density devices: slightly bigger board */
    @media (min-width:1100px){
      .board-wrap{ width: min(780px, 58vw); }
      .panel{ width:360px; padding:18px; border-radius:16px; }
    }

    /* accessibility: reduce motion */
    @media (prefers-reduced-motion: reduce){
      *{ transition: none !important; animation: none !important; }
    }

    /* captions / status */
    .labels { display:flex; gap:8px; align-items:center; justify-content:space-between; }
    .sr-only{ position: absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0 0 0 0); white-space:nowrap; border:0; }
  </style>
</head>
<body>
  <div class="wrap" id="appWrap">
    <div class="board-wrap" id="boardWrap">
      <canvas id="board" tabindex="0" aria-label="Chess board"></canvas>
    </div>

    <!-- hidden checkbox controls collapsed/expanded mobile panel without changing game JS -->
    <input type="checkbox" id="mobilePanelToggle" aria-hidden="true">

    <div class="panel" id="panel" aria-labelledby="panelTitle" role="region">
      <h2 id="panelTitle">JS Chess — Strong AI</h2>

      <div class="row labels"><label>Turn:</label> <div class="muted" id="turn" aria-live="polite">White</div></div>
      <div class="row labels"><label>Status:</label> <div class="muted" id="status" role="status" aria-live="polite">Ready</div></div>

      <div class="row" style="align-items:center">
        <label for="difficulty">Difficulty:</label>
        <select id="difficulty" name="difficulty" aria-label="AI difficulty">
          <option value="3">Easy (depth 3)</option>
          <option value="4" selected>Normal (depth 4)</option>
          <option value="5">Hard (depth 5)</option>
          <option value="6">Very Hard (depth 6 — slower)</option>
        </select>
      </div>

      <div class="controls" role="group" aria-label="Game controls">
        <button id="undo" title="Undo last move">Undo</button>
        <button id="reset" title="Reset the game">Reset</button>
      </div>

      <div class="footer muted" aria-hidden="true">Tap the board to select and move pieces. Double-click board to view cache size.</div>
    </div>

    <!-- floating toggle button for mobile (purely visual) -->
    <label for="mobilePanelToggle" class="panel-toggle" aria-hidden="true" title="Toggle controls">
      <!-- simple chevron icon -->
      <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true" focusable="false">
        <path d="M6 9l6 6 6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </label>

  </div>

  <script>
  (()=>{ 
    // Responsive single-file chess with mobile UX improvements and FULL-BACKGROUND red while thinking.
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const turnLabel = document.getElementById('turn');
    const statusLabel = document.getElementById('status');
    const difficultySelect = document.getElementById('difficulty');
    const undoBtn = document.getElementById('undo');
    const resetBtn = document.getElementById('reset');
    const body = document.body;

    // pieces (unicode)
    const PIECES = { p: '♟', r:'♜', n:'♞', b:'♝', q:'♛', k:'♚', P:'♙', R:'♖', N:'♘', B:'♗', Q:'♕', K:'♔' };

    // PST and MAT
    const PST = {
      p:[0,0,0,0,0,0,0,0,5,10,10,-20,-20,10,10,5,5,-5,-10,0,0,-10,-5,5,0,0,0,20,20,0,0,0,5,5,10,25,25,10,5,5,10,10,20,30,30,20,10,10,50,50,50,50,50,50,50,50,0,0,0,0,0,0,0,0],
      n:[-50,-40,-30,-30,-30,-30,-40,-50,-40,-20,0,0,0,0,-20,-40,-30,0,10,15,15,10,0,-30,-30,5,15,20,20,15,5,-30,-30,0,15,20,20,15,0,-30,-30,5,10,15,15,10,5,-30,-40,-20,0,5,5,0,-20,-40,-50,-40,-30,-30,-30,-30,-40,-50],
      b:[-20,-10,-10,-10,-10,-10,-10,-20,-10,5,0,0,0,0,5,-10,-10,10,10,10,10,10,10,-10,-10,0,10,10,10,10,0,-10,-10,5,5,10,10,5,5,-10,-10,0,5,10,10,5,0,-10,-20,-10,-10,-10,-10,-10,-10,-20],
      r:[0,0,5,10,10,5,0,0,-5,0,0,0,0,0,0,-5,-5,0,0,0,0,0,0,-5,-5,0,0,0,0,0,0,-5,-5,0,0,0,0,0,0,-5,5,10,10,10,10,10,10,5,0,0,0,0,0,0,0,0],
      q:[-20,-10,-10,-5,-5,-10,-10,-20,-10,0,5,0,0,0,0,-10,-10,5,5,5,5,5,0,-10,-5,0,5,5,5,5,0,-5,0,0,5,5,5,5,0,-5,-10,0,5,5,5,5,0,-10,-20,-10,-10,-5,-5,-10,-10,-20],
      k:[20,30,10,0,0,10,30,20,20,20,0,0,0,0,20,20,-10,-20,-20,-20,-20,-20,-20,-10,-20,-30,-30,-40,-40,-30,-30,-20,-30,-40,-40,-50,-50,-40,-40,-30,-30,-40,-40,-50,-50,-40,-40,-30]
    };
    const MAT = { p:100, n:320, b:330, r:500, q:900, k:20000 };

    // game state
    let board = [
      ["r","n","b","q","k","b","n","r"],
      ["p","p","p","p","p","p","p","p"],
      ["","","","","","","",""],
      ["","","","","","","",""],
      ["","","","","","","",""],
      ["","","","","","","",""],
      ["P","P","P","P","P","P","P","P"],
      ["R","N","B","Q","K","B","N","R"]
    ];

    let sideToMove = 'w';
    let castling = { K:true, Q:true, k:true, q:true };
    let enPassant = null;
    let halfmoveClock = 0;
    let fullmoveNumber = 1;
    const history = [];
    let selected = null;
    let legalMovesCache = [];
    const tt = new Map();

    // responsive drawing
    let TILE = 80;
    function inBoard(x,y){ return x>=0 && x<8 && y>=0 && y<8; }
    function pieceColor(p){ if(!p) return null; return p === p.toUpperCase() ? 'w' : 'b'; }
    function opposite(c){ return c === 'w' ? 'b' : 'w'; }
    function squareName(x,y){ return "abcdefgh"[x] + (8-y); }
    function parseSquare(s){ return { x: "abcdefgh".indexOf(s[0]), y: 8 - Number(s[1]) }; }

    function resizeCanvas(){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = canvas.getBoundingClientRect();
      const size = Math.min(rect.width, rect.height);
      canvas.width = Math.floor(size * dpr);
      canvas.height = Math.floor(size * dpr);
      canvas.style.width = size + 'px';
      canvas.style.height = size + 'px';
      ctx.setTransform(dpr,0,0,dpr,0,0);
      TILE = size / 8;
      drawBoardUI();
    }
    window.addEventListener('resize', () => { clearTimeout(window._resizeTO); window._resizeTO = setTimeout(resizeCanvas, 80); });

    function drawBoardUI(){
      for (let y=0;y<8;y++){
        for (let x=0;x<8;x++){
          let light = (x+y)%2 === 0;
          ctx.fillStyle = light ? '#f0d9b5' : '#b58863';
          ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
        }
      }
      if (selected){
        ctx.fillStyle = 'rgba(255,255,0,0.35)';
        ctx.fillRect(selected.x*TILE, selected.y*TILE, TILE, TILE);
        for (let m of legalMovesCache){
          if (m.sx === selected.x && m.sy === selected.y){
            ctx.beginPath();
            ctx.fillStyle = board[m.ty][m.tx] ? 'rgba(255,0,0,0.35)' : 'rgba(0,0,0,0.25)';
            ctx.arc(m.tx*TILE + TILE/2, m.ty*TILE + TILE/2, TILE/6, 0, Math.PI*2);
            ctx.fill();
          }
        }
      }
      for (let y=0;y<8;y++){
        for (let x=0;x<8;x++){
          const p = board[y][x];
          if (p){
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = Math.floor(TILE*0.75) + 'px serif';
            ctx.fillStyle = p === p.toUpperCase() ? '#fff' : '#000';
            ctx.fillText(PIECES[p], x*TILE + TILE/2, y*TILE + TILE/2 + 2);
          }
        }
      }
      turnLabel.textContent = sideToMove === 'w' ? 'White' : 'Black';
    }

    // move helpers & engine (kept similar to original, careful about correctness)
    function cloneBoard(b){ return b.map(r => r.slice()); }
    function makeMoveObj(sx,sy,tx,ty, promotion=null){
      const piece = board[sy][sx];
      const target = board[ty][tx];
      const isEP = (piece.toLowerCase()==='p' && enPassant && parseSquare(enPassant).x === tx && parseSquare(enPassant).y === ty && !target);
      return { sx,sy,tx,ty, piece, capture: target || (isEP ? (sideToMove==='w' ? 'p' : 'P') : ""), promotion, isEnPassant: isEP,
               prevEnPassant: enPassant, prevCastling: {...castling}, prevHalfmove: halfmoveClock, prevFullmove: fullmoveNumber };
    }

    function applyMove(m){
      history.push(m);
      if (m.piece.toLowerCase() === 'p' || m.capture) halfmoveClock = 0; else halfmoveClock++;
      if (sideToMove === 'b') fullmoveNumber++;
      if (m.isEnPassant){
        const capY = sideToMove === 'w' ? m.ty + 1 : m.ty - 1;
        board[capY][m.tx] = "";
      }
      board[m.ty][m.tx] = m.promotion ? m.promotion : m.piece;
      board[m.sy][m.sx] = "";
      if (m.piece === 'K' && Math.abs(m.tx - m.sx) === 2){
        if (m.tx === 6){ board[7][5] = 'R'; board[7][7] = ''; }
        else if (m.tx === 2){ board[7][3] = 'R'; board[7][0] = ''; }
      } else if (m.piece === 'k' && Math.abs(m.tx - m.sx) === 2){
        if (m.tx === 6){ board[0][5] = 'r'; board[0][7] = ''; }
        else if (m.tx === 2){ board[0][3] = 'r'; board[0][0] = ''; }
      }
      if (m.piece === 'K'){ castling.K = castling.Q = false; }
      if (m.piece === 'k'){ castling.k = castling.q = false; }
      if (m.piece === 'R'){
        if (m.sx === 0 && m.sy === 7) castling.Q = false;
        if (m.sx === 7 && m.sy === 7) castling.K = false;
      }
      if (m.piece === 'r'){
        if (m.sx === 0 && m.sy === 0) castling.q = false;
        if (m.sx === 7 && m.sy === 0) castling.k = false;
      }
      if (m.capture === 'r'){ if (m.tx === 0 && m.ty === 0) castling.q = false; if (m.tx === 7 && m.ty === 0) castling.k = false; }
      if (m.capture === 'R'){ if (m.tx === 0 && m.ty === 7) castling.Q = false; if (m.tx === 7 && m.ty === 7) castling.K = false; }
      if (m.piece.toLowerCase() === 'p' && Math.abs(m.ty - m.sy) === 2){
        const epY = (m.sy + m.ty) / 2;
        enPassant = squareName(m.sx, epY);
      } else { enPassant = null; }
      if (m.promotion){ board[m.ty][m.tx] = m.promotion; }
      sideToMove = opposite(sideToMove);
    }

    function undoMove(){
      const m = history.pop(); if(!m) return;
      sideToMove = opposite(sideToMove);
      halfmoveClock = m.prevHalfmove; fullmoveNumber = m.prevFullmove;
      enPassant = m.prevEnPassant; castling = {...m.prevCastling};
      board[m.sy][m.sx] = m.piece;
      board[m.ty][m.tx] = m.capture ? m.capture : "";
      if (m.isEnPassant){
        const capY = sideToMove === 'w' ? m.ty + 1 : m.ty - 1;
        board[capY][m.tx] = sideToMove === 'w' ? 'p' : 'P';
        board[m.ty][m.tx] = "";
      }
      if (m.piece === 'K' && Math.abs(m.tx - m.sx) === 2){
        if (m.tx === 6){ board[7][7] = 'R'; board[7][5] = ''; }
        else if (m.tx === 2){ board[7][0] = 'R'; board[7][3] = ''; }
      } else if (m.piece === 'k' && Math.abs(m.tx - m.sx) === 2){
        if (m.tx === 6){ board[0][7] = 'r'; board[0][5] = ''; }
        else if (m.tx === 2){ board[0][0] = 'r'; board[0][3] = ''; }
      }
    }

    function isSquareAttacked(x,y,byColor){
      if (byColor === 'w'){
        const py = y + 1;
        if (inBoard(x-1,py) && board[py][x-1] === 'P') return true;
        if (inBoard(x+1,py) && board[py][x+1] === 'P') return true;
      } else {
        const py = y - 1;
        if (inBoard(x-1,py) && board[py][x-1] === 'p') return true;
        if (inBoard(x+1,py) && board[py][x+1] === 'p') return true;
      }
      const nMoves = [[1,2],[2,1],[2,-1],[1,-2],[-1,-2],[-2,-1],[-2,1],[-1,2]];
      for (let [dx,dy] of nMoves){ const nx = x+dx, ny = y+dy; if (inBoard(nx,ny)){ const q = board[ny][nx]; if (q && ((byColor==='w' && q==='N') || (byColor==='b' && q==='n'))) return true; }}
      const orth = [[1,0],[-1,0],[0,1],[0,-1]];
      for (let [dx,dy] of orth){ let nx=x+dx, ny=y+dy; while(inBoard(nx,ny)){ const q = board[ny][nx]; if (q){ if (byColor==='w' && (q==='R' || q==='Q')) return true; if (byColor==='b' && (q==='r' || q==='q')) return true; break; } nx+=dx; ny+=dy; }}
      const diag = [[1,1],[1,-1],[-1,1],[-1,-1]];
      for (let [dx,dy] of diag){ let nx=x+dx, ny=y+dy; while(inBoard(nx,ny)){ const q = board[ny][nx]; if (q){ if (byColor==='w' && (q==='B' || q==='Q')) return true; if (byColor==='b' && (q==='b' || q==='q')) return true; break; } nx+=dx; ny+=dy; }}
      for (let dx=-1; dx<=1; dx++) for (let dy=-1; dy<=1; dy++){ if (dx===0 && dy===0) continue; const nx = x+dx, ny = y+dy; if (inBoard(nx,ny)){ const q = board[ny][nx]; if (q && ((byColor==='w' && q==='K') || (byColor==='b' && q==='k'))) return true; }}
      return false;
    }

    function findKing(color){ const target = color === 'w' ? 'K' : 'k'; for (let y=0;y<8;y++) for (let x=0;x<8;x++) if (board[y][x] === target) return {x,y}; return null; }
    function inCheck(color){ const k = findKing(color); if (!k) return false; return isSquareAttacked(k.x, k.y, opposite(color)); }

    function generatePseudoLegalMoves(color){
      const moves = [];
      for (let y=0;y<8;y++){
        for (let x=0;x<8;x++){
          const p = board[y][x];
          if (!p) continue;
          if (color === 'w' && p !== p.toUpperCase()) continue;
          if (color === 'b' && p !== p.toLowerCase()) continue;
          const lower = p.toLowerCase();
          if (lower === 'p'){
            const dir = p === 'P' ? -1 : 1;
            const startRow = p === 'P' ? 6 : 1;
            const fy = y + dir;
            if (inBoard(x, fy) && !board[fy][x]){
              if (fy === 0 || fy === 7){
                for (let promo of (p === 'P' ? ['Q','R','B','N'] : ['q','r','b','n'])) moves.push({sx:x,sy:y,tx:x,ty:fy,promotion:promo});
              } else moves.push({sx:x,sy:y,tx:x,ty:fy});
              if (y === startRow){ const fy2 = y + 2*dir; if (!board[fy2][x]) moves.push({sx:x,sy:y,tx:x,ty:fy2}); }
            }
            for (let cx of [x-1,x+1]){
              if (inBoard(cx, fy)){
                const t = board[fy][cx];
                if (t && pieceColor(t) !== pieceColor(p)){
                  if (fy === 0 || fy === 7){ for (let promo of (p === 'P' ? ['Q','R','B','N'] : ['q','r','b','n'])) moves.push({sx:x,sy:y,tx:cx,ty:fy,capture:t,promotion:promo}); }
                  else moves.push({sx:x,sy:y,tx:cx,ty:fy,capture:t});
                }
              }
            }
            if (enPassant){ const ep = parseSquare(enPassant); if (fy === ep.y && Math.abs(ep.x - x) === 1) moves.push({sx:x,sy:y,tx:ep.x,ty:ep.y,isEnPassant:true}); }
          } else if (lower === 'n'){
            const deltas = [[1,2],[2,1],[2,-1],[1,-2],[-1,-2],[-2,-1],[-2,1],[-1,2]];
            for (let [dx,dy] of deltas){ const nx = x+dx, ny = y+dy; if (!inBoard(nx,ny)) continue; const t = board[ny][nx]; if (!t || pieceColor(t) !== pieceColor(p)) moves.push({sx:x,sy:y,tx:nx,ty:ny,capture:t || ''}); }
          } else if (lower === 'b' || lower === 'r' || lower === 'q'){
            const dirs = lower === 'b' ? [[1,1],[1,-1],[-1,1],[-1,-1]] : lower === 'r' ? [[1,0],[-1,0],[0,1],[0,-1]] : [[1,1],[1,-1],[-1,1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]];
            for (let [dx,dy] of dirs){ let nx = x+dx, ny = y+dy; while (inBoard(nx,ny)){ const t = board[ny][nx]; if (!t) moves.push({sx:x,sy:y,tx:nx,ty:ny}); else { if (pieceColor(t) !== pieceColor(p)) moves.push({sx:x,sy:y,tx:nx,ty:ny,capture:t}); break; } nx += dx; ny += dy; }
            }
          } else if (lower === 'k'){
            for (let dx=-1; dx<=1; dx++) for (let dy=-1; dy<=1; dy++){ if (dx===0 && dy===0) continue; const nx = x+dx, ny = y+dy; if (!inBoard(nx,ny)) continue; const t = board[ny][nx]; if (!t || pieceColor(t) !== pieceColor(p)) moves.push({sx:x,sy:y,tx:nx,ty:ny,capture:t || ''}); }
            if (p === 'K' && !inCheck('w')){
              if (castling.K && !board[7][5] && !board[7][6] && !isSquareAttacked(5,7,'b') && !isSquareAttacked(6,7,'b')) moves.push({sx:x,sy:y,tx:6,ty:7,isCastle:true});
              if (castling.Q && !board[7][1] && !board[7][2] && !board[7][3] && !isSquareAttacked(2,7,'b') && !isSquareAttacked(3,7,'b')) moves.push({sx:x,sy:y,tx:2,ty:7,isCastle:true});
            }
            if (p === 'k' && !inCheck('b')){
              if (castling.k && !board[0][5] && !board[0][6] && !isSquareAttacked(5,0,'w') && !isSquareAttacked(6,0,'w')) moves.push({sx:x,sy:y,tx:6,ty:0,isCastle:true});
              if (castling.q && !board[0][1] && !board[0][2] && !board[0][3] && !isSquareAttacked(2,0,'w') && !isSquareAttacked(3,0,'w')) moves.push({sx:x,sy:y,tx:2,ty:0,isCastle:true});
            }
          }
        }
      }
      return moves;
    }

    function generateLegalMoves(color){
      const pseudo = generatePseudoLegalMoves(color);
      const legal = [];
      for (let m of pseudo){
        const move = makeMoveObj(m.sx,m.sy,m.tx,m.ty, m.promotion || null);
        move.isEnPassant = !!m.isEnPassant; move.isCastle = !!m.isCastle;
        applyMove(move);
        const stillInCheck = inCheck(color);
        undoMove();
        if (!stillInCheck) legal.push({...move});
      }
      return legal;
    }

    function gameStatus(){
      const legal = generateLegalMoves(sideToMove === 'w' ? 'w' : 'b');
      if (legal.length === 0){
        if (inCheck(sideToMove === 'w' ? 'w' : 'b')) return { result: 'checkmate', winner: sideToMove === 'w' ? 'b' : 'w' };
        else return { result: 'stalemate', winner: null };
      }
      return { result: 'playing' };
    }

    function evaluate(){
      let score = 0;
      for (let y=0;y<8;y++){
        for (let x=0;x<8;x++){
          const p = board[y][x]; if (!p) continue; const lower = p.toLowerCase(); const val = MAT[lower]; const idx = y*8 + x; const pst = PST[lower] || new Array(64).fill(0); const psVal = (p === p.toUpperCase() ? 1 : -1) * pst[idx]; score += (p === p.toUpperCase() ? 1 : -1) * val + psVal;
        }
      }
      return score * (sideToMove === 'w' ? 1 : -1);
    }

    function scoreMoveForOrdering(m){ if (m.capture){ const victim = m.capture.toLowerCase(); const attacker = m.piece.toLowerCase(); return (MAT[victim] * 10) - MAT[attacker]; } if (m.promotion) return 2000; return 0; }

    function positionKey(){ return board.flat().map(s => s ? s : '.').join('') + ' ' + sideToMove + ' ' + (castling.K? 'K':'' ) + (castling.Q? 'Q':'') + (castling.k? 'k':'') + (castling.q? 'q':'') + ' ' + (enPassant? enPassant : '-'); }

    let nodes = 0;
    function alphaBeta(depth, alpha, beta, maximizing){
      const key = positionKey() + ' ' + depth + ' ' + (maximizing? '1':'0');
      if (tt.has(key)) return tt.get(key);
      nodes++;
      if (depth === 0){ const v = evaluate(); tt.set(key, v); return v; }
      const color = maximizing ? (sideToMove === 'w' ? 'w' : 'b') : opposite(sideToMove === 'w' ? 'w' : 'b');
      let moves = generateLegalMoves(maximizing ? sideToMove === 'w' ? 'w' : 'b' : opposite(sideToMove === 'w' ? 'w' : 'b'));
      moves.sort((a,b) => scoreMoveForOrdering(b) - scoreMoveForOrdering(a));
      if (moves.length === 0){ const v = evaluate(); tt.set(key, v); return v; }
      if (maximizing){
        let value = -Infinity;
        for (let m of moves){ applyMove(m); const val = alphaBeta(depth-1, alpha, beta, false); undoMove(); if (val > value) value = val; if (val > alpha) alpha = val; if (alpha >= beta) break; }
        tt.set(key, value); return value;
      } else {
        let value = Infinity;
        for (let m of moves){ applyMove(m); const val = alphaBeta(depth-1, alpha, beta, true); undoMove(); if (val < value) value = val; if (val < beta) beta = val; if (alpha >= beta) break; }
        tt.set(key, value); return value;
      }
    }

    async function thinkAndMove(maxDepth){
      // full-background red while thinking
      body.classList.add('ai-thinking');
      statusLabel.textContent = 'Thinking...';
      nodes = 0; tt.clear();
      let bestMove = null;
      for (let depth = 1; depth <= maxDepth; depth++){
        let bestScore = -Infinity;
        let moves = generateLegalMoves('b');
        moves.sort((a,b) => scoreMoveForOrdering(b) - scoreMoveForOrdering(a));
        for (let m of moves){ applyMove(m); const score = alphaBeta(depth-1, -Infinity, Infinity, true); undoMove(); if (score > bestScore){ bestScore = score; bestMove = m; } }
        statusLabel.textContent = `Depth ${depth} — nodes ${nodes} — best ${Math.round(bestScore)}`;
        await new Promise(r => setTimeout(r, 8));
      }
      if (bestMove){ applyMove(bestMove); drawBoardUI(); }
      body.classList.remove('ai-thinking');
      statusLabel.textContent = 'Move done';
    }

    // pointer handling (mouse & touch unified)
    function getBoardCoordsFromPointer(ev){
      const rect = canvas.getBoundingClientRect();
      const clientX = ev.clientX !== undefined ? ev.clientX : (ev.touches && ev.touches[0] && ev.touches[0].clientX);
      const clientY = ev.clientY !== undefined ? ev.clientY : (ev.touches && ev.touches[0] && ev.touches[0].clientY);
      const cx = clientX - rect.left;
      const cy = clientY - rect.top;
      const x = Math.floor((cx / rect.width) * 8);
      const y = Math.floor((cy / rect.height) * 8);
      return { x: Math.max(0, Math.min(7, x)), y: Math.max(0, Math.min(7, y)) };
    }

    async function onPointerDown(ev){
      ev.preventDefault();
      if (sideToMove !== 'w') return;
      const pos = getBoardCoordsFromPointer(ev);
      const x = pos.x, y = pos.y;
      if (!selected){ const p = board[y][x]; if (p && pieceColor(p) === 'w'){ selected = {x,y}; legalMovesCache = generateLegalMoves('w'); } }
      else {
        const allLegal = generateLegalMoves('w');
        const candidate = allLegal.find(m => m.sx === selected.x && m.sy === selected.y && m.tx === x && m.ty === y);
        if (candidate){
          if (candidate.promotion && !candidate.promotionSpecified){ const choice = prompt('Promote to (Q/R/B/N). Default Q').toUpperCase() || 'Q'; const prom = {'Q':'Q','R':'R','B':'B','N':'N'}[choice] || 'Q'; candidate.promotion = prom; }
          applyMove(candidate);
          selected = null; legalMovesCache = [];
          drawBoardUI();
          const st = gameStatus();
          if (st.result === 'playing'){
            sideToMove = 'b'; turnLabel.textContent = 'Black (AI)';
            const depth = Number(difficultySelect.value);
            await thinkAndMove(depth);
            const st2 = gameStatus();
            if (st2.result === 'checkmate'){ statusLabel.textContent = `Checkmate — ${st2.winner==='w'?'White':'Black'} wins`; }
            else if (st2.result === 'stalemate'){ statusLabel.textContent = 'Stalemate (draw)'; }
            else { statusLabel.textContent = 'Your move'; }
          } else { if (st.result === 'checkmate') statusLabel.textContent = `Checkmate — ${st.winner==='w'?'White':'Black'} wins`; else statusLabel.textContent = 'Stalemate (draw)'; }
        } else {
          const p2 = board[y][x]; if (p2 && pieceColor(p2) === 'w'){ selected = {x,y}; legalMovesCache = generateLegalMoves('w'); } else { selected = null; legalMovesCache = []; }
        }
      }
      drawBoardUI();
    }

    canvas.addEventListener('pointerdown', onPointerDown, { passive:false });

    undoBtn.addEventListener('click', ()=>{
      undoMove();
      if (sideToMove === 'b' && history.length) undoMove();
      selected = null; legalMovesCache = []; drawBoardUI(); statusLabel.textContent = 'Undone'; body.classList.remove('ai-thinking');
    });

    resetBtn.addEventListener('click', ()=>{
      board = [
        ["r","n","b","q","k","b","n","r"],
        ["p","p","p","p","p","p","p","p"],
        ["","","","","","","",""],
        ["","","","","","","",""],
        ["","","","","","","",""],
        ["","","","","","","",""],
        ["P","P","P","P","P","P","P","P"],
        ["R","N","B","Q","K","B","N","R"]
      ];
      sideToMove='w'; castling={K:true,Q:true,k:true,q:true}; enPassant=null; halfmoveClock=0; fullmoveNumber=1; history.length=0; tt.clear(); selected=null; legalMovesCache=[]; drawBoardUI(); statusLabel.textContent='Reset'; body.classList.remove('ai-thinking');
    });

    // initial draw
    setTimeout(resizeCanvas, 30);
    canvas.addEventListener('dblclick', ()=>{ statusLabel.textContent = `Cache: ${tt.size}`; setTimeout(()=> statusLabel.textContent='Ready', 1200); });
    canvas.setAttribute('role','application'); canvas.setAttribute('aria-label','Chess board');

    // optional: close mobile panel when tapping board (so board is fully visible again)
    const mobileToggle = document.getElementById('mobilePanelToggle');
    canvas.addEventListener('pointerdown', ()=>{
      if (window.matchMedia('(max-width:880px)').matches && mobileToggle && mobileToggle.checked){ mobileToggle.checked = false; }
    });

  })();
  </script>
</body>
</html>
