<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>JS Chess — Strong AI (Full)</title>
</head>
<body>
<script>
(() => {
  // High-quality Chess (Playable vs AI) - Paste and run in browser console
  // Human = White, AI = Black. Click to select and move. AI thinks with iterative deepening.

  // ---------- UI Setup ----------
  document.body.innerHTML = "";
  document.body.style.margin = "0";
  document.body.style.background = "#111";
  document.body.style.display = "flex";
  document.body.style.justifyContent = "center";
  document.body.style.alignItems = "flex-start";
  document.body.style.padding = "20px";
  document.body.style.fontFamily = "Arial, sans-serif";

  const container = document.createElement("div");
  document.body.appendChild(container);

  // Left: canvas
  const S = 640;
  const TILE = S / 8;
  const canvas = document.createElement("canvas");
  canvas.width = canvas.height = S;
  canvas.style.boxShadow = "0 6px 18px rgba(0,0,0,0.6)";
  container.appendChild(canvas);
  const ctx = canvas.getContext("2d");

  // Right: controls
  const panel = document.createElement("div");
  panel.style.color = "white";
  panel.style.marginLeft = "20px";
  panel.style.width = "300px";
  container.appendChild(panel);

  panel.innerHTML = `
    <h2 style="margin:6px 0 12px 0;color:#fff">JS Chess — Strong AI</h2>
    <div style="margin-bottom:10px">Turn: <span id="turn">White</span></div>
    <div style="margin-bottom:10px">Status: <span id="status">Ready</span></div>
    <div style="margin-bottom:12px">Difficulty: <select id="difficulty">
      <option value="3">Easy (depth 3)</option>
      <option value="4" selected>Normal (depth 4)</option>
      <option value="5">Hard (depth 5)</option>
      <option value="6">Very Hard (depth 6 — slower)</option>
    </select></div>
    <button id="undo" style="margin-right:8px">Undo</button>
    <button id="reset">Reset</button>
    <div style="margin-top:12px;font-size:13px;color:#ddd">
      Click a piece to select it, then click a destination.
      Promotion defaults to Queen; UI asks on promotion.
    </div>
  `;

  const turnLabel = panel.querySelector("#turn");
  const statusLabel = panel.querySelector("#status");
  const difficultySelect = panel.querySelector("#difficulty");
  const undoBtn = panel.querySelector("#undo");
  const resetBtn = panel.querySelector("#reset");

  // ---------- Board & Pieces ----------
  const PIECES = {
    p: "♟", r: "♜", n: "♞", b: "♝", q: "♛", k: "♚",
    P: "♙", R: "♖", N: "♘", B: "♗", Q: "♕", K: "♔"
  };

  // Piece-square tables (small positional nudges)
  const PST = {
    p: [
       0,  0,  0,  0,  0,  0,  0,  0,
       5, 10, 10,-20,-20, 10, 10,  5,
       5, -5,-10,  0,  0,-10, -5,  5,
       0,  0,  0, 20, 20,  0,  0,  0,
       5,  5, 10, 25, 25, 10,  5,  5,
      10, 10, 20, 30, 30, 20, 10, 10,
      50, 50, 50, 50, 50, 50, 50, 50,
       0,  0,  0,  0,  0,  0,  0,  0
    ],
    n: [
      -50,-40,-30,-30,-30,-30,-40,-50,
      -40,-20,  0,  0,  0,  0,-20,-40,
      -30,  0, 10, 15, 15, 10,  0,-30,
      -30,  5, 15, 20, 20, 15,  5,-30,
      -30,  0, 15, 20, 20, 15,  0,-30,
      -30,  5, 10, 15, 15, 10,  5,-30,
      -40,-20,  0,  5,  5,  0,-20,-40,
      -50,-40,-30,-30,-30,-30,-40,-50
    ],
    b: [
      -20,-10,-10,-10,-10,-10,-10,-20,
      -10,  5,  0,  0,  0,  0,  5,-10,
      -10, 10, 10, 10, 10, 10, 10,-10,
      -10,  0, 10, 10, 10, 10,  0,-10,
      -10,  5,  5, 10, 10,  5,  5,-10,
      -10,  0,  5, 10, 10,  5,  0,-10,
      -10,  0,  0,  0,  0,  0,  0,-10,
      -20,-10,-10,-10,-10,-10,-10,-20
    ],
    r: [
        0,  0,  5, 10, 10,  5,  0,  0,
       -5,  0,  0,  0,  0,  0,  0, -5,
       -5,  0,  0,  0,  0,  0,  0, -5,
       -5,  0,  0,  0,  0,  0,  0, -5,
       -5,  0,  0,  0,  0,  0,  0, -5,
       -5,  0,  0,  0,  0,  0,  0, -5,
        5, 10, 10, 10, 10, 10, 10,  5,
        0,  0,  0,  0,  0,  0,  0,  0
    ],
    q: [
      -20,-10,-10, -5, -5,-10,-10,-20,
      -10,  0,  5,  0,  0,  0,  0,-10,
      -10,  5,  5,  5,  5,  5,  0,-10,
       -5,  0,  5,  5,  5,  5,  0, -5,
        0,  0,  5,  5,  5,  5,  0, -5,
      -10,  0,  5,  5,  5,  5,  0,-10,
      -10,  0,  0,  0,  0,  0,  0,-10,
      -20,-10,-10, -5, -5,-10,-10,-20
    ],
    k: [
       20, 30, 10,  0,  0, 10, 30, 20,
       20, 20,  0,  0,  0,  0, 20, 20,
      -10,-20,-20,-20,-20,-20,-20,-10,
      -20,-30,-30,-40,-40,-30,-30,-20,
      -30,-40,-40,-50,-50,-40,-40,-30,
      -30,-40,-40,-50,-50,-40,-40,-30,
      -30,-40,-40,-50,-50,-40,-40,-30,
      -30,-40,-40,-50,-50,-40,-40,-30
    ]
  };

  // material values
  const MAT = { p:100, n:320, b:330, r:500, q:900, k:20000 };

  // ---------- Game State ----------
  // board[y][x] with 0,0 top-left; white pieces uppercase, black lowercase, "" empty
  let board = [
    ["r","n","b","q","k","b","n","r"],
    ["p","p","p","p","p","p","p","p"],
    ["","","","","","","",""],
    ["","","","","","","",""],
    ["","","","","","","",""],
    ["","","","","","","",""],
    ["P","P","P","P","P","P","P","P"],
    ["R","N","B","Q","K","B","N","R"]
  ];

  let sideToMove = "w"; // 'w' or 'b'
  let castling = { K:true, Q:true, k:true, q:true }; // castling rights
  let enPassant = null; // square string like "e3" or null
  let halfmoveClock = 0;
  let fullmoveNumber = 1;

  // history stack for unmake
  const history = [];

  // UI selection
  let selected = null;
  let legalMovesCache = [];

  // transposition table
  const tt = new Map();

  // ---------- Helpers ----------
  function coordToIndex(x,y){ return y*8 + x; }
  function inBoard(x,y){ return x>=0 && x<8 && y>=0 && y<8; }
  function cloneBoard(b){
    return b.map(r => r.slice());
  }
  function pieceColor(p){ if(!p) return null; return p === p.toUpperCase() ? 'w' : 'b'; }
  function opposite(c){ return c === 'w' ? 'b' : 'w'; }
  function squareName(x,y){ return "abcdefgh"[x] + (8-y); }
  function parseSquare(s){ return { x:"abcdefgh".indexOf(s[0]), y:8 - Number(s[1]) }; }

  // ---------- Drawing ----------
  function drawBoardUI() {
    // background
    for (let y=0;y<8;y++){
      for (let x=0;x<8;x++){
        let light = (x+y)%2 === 0;
        ctx.fillStyle = light ? "#f0d9b5" : "#b58863";
        ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
      }
    }
    // highlight selected and legal moves
    if (selected) {
      ctx.fillStyle = "rgba(255,255,0,0.4)";
      ctx.fillRect(selected.x*TILE, selected.y*TILE, TILE, TILE);
      for (let m of legalMovesCache){
        if (m.sx === selected.x && m.sy === selected.y){
          ctx.beginPath();
          ctx.fillStyle = board[m.ty][m.tx] ? "rgba(255,0,0,0.35)" : "rgba(0,0,0,0.25)";
          ctx.arc(m.tx*TILE + TILE/2, m.ty*TILE + TILE/2, TILE/6, 0, Math.PI*2);
          ctx.fill();
        }
      }
    }

    // draw pieces
    for (let y=0;y<8;y++){
      for (let x=0;x<8;x++){
        let p = board[y][x];
        if (p){
          ctx.font = `${Math.floor(TILE*0.75)}px Arial`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillStyle = p === p.toUpperCase() ? "#fff" : "#000";
          ctx.fillText(PIECES[p], x*TILE + TILE/2, y*TILE + TILE/2 + 2);
        }
      }
    }

    // turn & status
    turnLabel.textContent = sideToMove === 'w' ? "White" : "Black";
  }

  // ---------- Move Representation ----------
  // move: {sx,sy,tx,ty, piece, capture, promotion, isEnPassant, prevEnPassant, prevCastling, prevHalfmove}
  function makeMoveObj(sx,sy,tx,ty, promotion=null){
    const piece = board[sy][sx];
    const target = board[ty][tx];
    const isEP = (piece.toLowerCase()==='p' && enPassant && parseSquare(enPassant).x === tx && parseSquare(enPassant).y === ty && !target);
    return { sx,sy,tx,ty, piece, capture: target || (isEP ? (sideToMove==='w' ? 'p' : 'P') : ""), promotion, isEnPassant: isEP,
             prevEnPassant: enPassant, prevCastling: {...castling}, prevHalfmove: halfmoveClock, prevFullmove: fullmoveNumber };
  }

  function applyMove(m){
    // push history
    history.push(m);

    // update halfmove/fullmove
    if (m.piece.toLowerCase() === 'p' || m.capture) halfmoveClock = 0; else halfmoveClock++;
    if (sideToMove === 'b') fullmoveNumber++;

    // handle en passant capture
    if (m.isEnPassant){
      const capY = sideToMove === 'w' ? m.ty + 1 : m.ty - 1;
      board[capY][m.tx] = "";
    }

    // move the piece
    board[m.ty][m.tx] = m.promotion ? m.promotion : m.piece;
    board[m.sy][m.sx] = "";

    // handle castling (move rook)
    if (m.piece === "K" && Math.abs(m.tx - m.sx) === 2){
      // white castle
      if (m.tx === 6){ board[7][5] = "R"; board[7][7] = ""; }
      else if (m.tx === 2){ board[7][3] = "R"; board[7][0] = ""; }
    } else if (m.piece === "k" && Math.abs(m.tx - m.sx) === 2){
      if (m.tx === 6){ board[0][5] = "r"; board[0][7] = ""; }
      else if (m.tx === 2){ board[0][3] = "r"; board[0][0] = ""; }
    }

    // update castling rights if king or rook moved/captured
    if (m.piece === 'K'){ castling.K = castling.Q = false; }
    if (m.piece === 'k'){ castling.k = castling.q = false; }
    if (m.piece === 'R'){
      if (m.sx === 0 && m.sy === 7) castling.Q = false;
      if (m.sx === 7 && m.sy === 7) castling.K = false;
    }
    if (m.piece === 'r'){
      if (m.sx === 0 && m.sy === 0) castling.q = false;
      if (m.sx === 7 && m.sy === 0) castling.k = false;
    }
    // if rook captured
    if (m.capture === 'r'){ if (m.tx === 0 && m.ty === 0) castling.q = false; if (m.tx === 7 && m.ty === 0) castling.k = false; }
    if (m.capture === 'R'){ if (m.tx === 0 && m.ty === 7) castling.Q = false; if (m.tx === 7 && m.ty === 7) castling.K = false; }

    // update enPassant: if a pawn moved two squares, set ep square else null
    if (m.piece.toLowerCase() === 'p' && Math.abs(m.ty - m.sy) === 2){
      const epY = (m.sy + m.ty) / 2;
      enPassant = squareName(m.sx, epY);
    } else {
      enPassant = null;
    }

    // promote
    if (m.promotion){
      board[m.ty][m.tx] = m.promotion;
    }

    sideToMove = opposite(sideToMove);
  }

  function undoMove(){
    const m = history.pop();
    if (!m) return;
    // restore side
    sideToMove = opposite(sideToMove);

    // restore fullmove/halfmove
    halfmoveClock = m.prevHalfmove;
    fullmoveNumber = m.prevFullmove;

    // restore castling & enPassant
    enPassant = m.prevEnPassant;
    castling = {...m.prevCastling};

    // undo special cases
    // undo promotion (simply set moving piece back)
    board[m.sy][m.sx] = m.piece;
    // restore capture for regular capture
    board[m.ty][m.tx] = m.capture ? m.capture : "";

    // if en passant capture, restore the captured pawn
    if (m.isEnPassant){
      const capY = sideToMove === 'w' ? m.ty + 1 : m.ty - 1;
      board[capY][m.tx] = sideToMove === 'w' ? 'p' : 'P';
      board[m.ty][m.tx] = "";
    }

    // undo castling rook move
    if (m.piece === "K" && Math.abs(m.tx - m.sx) === 2){
      if (m.tx === 6){ board[7][7] = "R"; board[7][5] = ""; }
      else if (m.tx === 2){ board[7][0] = "R"; board[7][3] = ""; }
    } else if (m.piece === "k" && Math.abs(m.tx - m.sx) === 2){
      if (m.tx === 6){ board[0][7] = "r"; board[0][5] = ""; }
      else if (m.tx === 2){ board[0][0] = "r"; board[0][3] = ""; }
    }
  }

  // ---------- Attack detection ----------
  function isSquareAttacked(x, y, byColor){
    // check pawn attacks
    if (byColor === 'w'){
      const py = y + 1;
      if (inBoard(x-1,py) && board[py][x-1] === 'P') return true;
      if (inBoard(x+1,py) && board[py][x+1] === 'P') return true;
    } else {
      const py = y - 1;
      if (inBoard(x-1,py) && board[py][x-1] === 'p') return true;
      if (inBoard(x+1,py) && board[py][x+1] === 'p') return true;
    }

    // knights
    const nMoves = [[1,2],[2,1],[2,-1],[1,-2],[-1,-2],[-2,-1],[-2,1],[-1,2]];
    for (let [dx,dy] of nMoves){
      const nx = x+dx, ny = y+dy;
      if (inBoard(nx,ny)){
        const q = board[ny][nx];
        if (q && ((byColor==='w' && q==='N') || (byColor==='b' && q==='n'))) return true;
      }
    }

    // sliding: rook/queen (orthogonal)
    const orth = [[1,0],[-1,0],[0,1],[0,-1]];
    for (let [dx,dy] of orth){
      let nx=x+dx, ny=y+dy;
      while(inBoard(nx,ny)){
        const q = board[ny][nx];
        if (q){
          if (byColor==='w' && (q==='R' || q==='Q')) return true;
          if (byColor==='b' && (q==='r' || q==='q')) return true;
          break;
        }
        nx+=dx; ny+=dy;
      }
    }

    // sliding: bishop/queen (diagonal)
    const diag = [[1,1],[1,-1],[-1,1],[-1,-1]];
    for (let [dx,dy] of diag){
      let nx=x+dx, ny=y+dy;
      while(inBoard(nx,ny)){
        const q = board[ny][nx];
        if (q){
          if (byColor==='w' && (q==='B' || q==='Q')) return true;
          if (byColor==='b' && (q==='b' || q==='q')) return true;
          break;
        }
        nx+=dx; ny+=dy;
      }
    }

    // king adjacency
    for (let dx=-1; dx<=1; dx++){
      for (let dy=-1; dy<=1; dy++){
        if (dx===0 && dy===0) continue;
        const nx = x+dx, ny = y+dy;
        if (inBoard(nx,ny)){
          const q = board[ny][nx];
          if (q && ((byColor==='w' && q==='K') || (byColor==='b' && q==='k'))) return true;
        }
      }
    }

    return false;
  }

  // find king coords
  function findKing(color){
    const target = color === 'w' ? 'K' : 'k';
    for (let y=0;y<8;y++) for (let x=0;x<8;x++) if (board[y][x]===target) return {x,y};
    return null;
  }

  function inCheck(color){
    const k = findKing(color);
    if (!k) return false;
    return isSquareAttacked(k.x, k.y, opposite(color));
  }

  // ---------- Move generation (pseudo-legal then filter) ----------
  function generatePseudoLegalMoves(color){
    const moves = [];
    for (let y=0;y<8;y++){
      for (let x=0;x<8;x++){
        const p = board[y][x];
        if (!p) continue;
        if (color === 'w' && p !== p.toUpperCase()) continue;
        if (color === 'b' && p !== p.toLowerCase()) continue;

        const lower = p.toLowerCase();
        if (lower === 'p'){
          const dir = p === 'P' ? -1 : 1;
          const startRow = p === 'P' ? 6 : 1;
          // forward 1
          const fy = y + dir;
          if (inBoard(x, fy) && !board[fy][x]) {
            // promotion?
            if (fy === 0 || fy === 7){
              for (let promo of (p === 'P' ? ['Q','R','B','N'] : ['q','r','b','n']))
                moves.push({sx:x,sy:y,tx:x,ty:fy, promotion: promo});
            } else {
              moves.push({sx:x,sy:y,tx:x,ty:fy});
            }
            // forward 2
            if (y === startRow){
              const fy2 = y + 2*dir;
              if (!board[fy2][x]) moves.push({sx:x,sy:y,tx:x,ty:fy2});
            }
          }
          // captures
          for (let cx of [x-1, x+1]){
            if (inBoard(cx, fy)){
              const t = board[fy][cx];
              if (t && pieceColor(t) !== pieceColor(p)){
                if (fy === 0 || fy === 7){
                  for (let promo of (p === 'P' ? ['Q','R','B','N'] : ['q','r','b','n']))
                    moves.push({sx:x,sy:y,tx:cx,ty:fy, capture: t, promotion: promo});
                } else {
                  moves.push({sx:x,sy:y,tx:cx,ty:fy, capture: t});
                }
              }
            }
          }
          // en passant
          if (enPassant){
            const ep = parseSquare(enPassant);
            if (fy === ep.y && Math.abs(ep.x - x) === 1){
              moves.push({sx:x,sy:y,tx:ep.x,ty:ep.y, isEnPassant:true});
            }
          }
        } else if (lower === 'n'){
          const deltas = [[1,2],[2,1],[2,-1],[1,-2],[-1,-2],[-2,-1],[-2,1],[-1,2]];
          for (let [dx,dy] of deltas){
            const nx = x+dx, ny = y+dy;
            if (!inBoard(nx,ny)) continue;
            const t = board[ny][nx];
            if (!t || pieceColor(t) !== pieceColor(p)) moves.push({sx:x,sy:y,tx:nx,ty:ny, capture:t || ""});
          }
        } else if (lower === 'b' || lower === 'r' || lower === 'q'){
          const dirs = lower === 'b' ? [[1,1],[1,-1],[-1,1],[-1,-1]] :
                       lower === 'r' ? [[1,0],[-1,0],[0,1],[0,-1]] :
                       [[1,1],[1,-1],[-1,1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]];
          for (let [dx,dy] of dirs){
            let nx = x+dx, ny = y+dy;
            while(inBoard(nx,ny)){
              const t = board[ny][nx];
              if (!t){ moves.push({sx:x,sy:y,tx:nx,ty:ny}); }
              else {
                if (pieceColor(t) !== pieceColor(p)) moves.push({sx:x,sy:y,tx:nx,ty:ny, capture:t});
                break;
              }
              nx+=dx; ny+=dy;
            }
          }
        } else if (lower === 'k'){
          for (let dx=-1; dx<=1; dx++){
            for (let dy=-1; dy<=1; dy++){
              if (dx===0 && dy===0) continue;
              const nx = x+dx, ny = y+dy;
              if (!inBoard(nx,ny)) continue;
              const t = board[ny][nx];
              if (!t || pieceColor(t) !== pieceColor(p)) moves.push({sx:x,sy:y,tx:nx,ty:ny, capture:t || ""});
            }
          }
          // castling
          if (p === 'K' && !inCheck('w')){
            // king side
            if (castling.K && !board[7][5] && !board[7][6] && !isSquareAttacked(5,7,'b') && !isSquareAttacked(6,7,'b')){
              moves.push({sx:x,sy:y,tx:6,ty:7, isCastle:true});
            }
            // queen side
            if (castling.Q && !board[7][1] && !board[7][2] && !board[7][3] && !isSquareAttacked(2,7,'b') && !isSquareAttacked(3,7,'b')){
              moves.push({sx:x,sy:y,tx:2,ty:7, isCastle:true});
            }
          }
          if (p === 'k' && !inCheck('b')){
            if (castling.k && !board[0][5] && !board[0][6] && !isSquareAttacked(5,0,'w') && !isSquareAttacked(6,0,'w')){
              moves.push({sx:x,sy:y,tx:6,ty:0, isCastle:true});
            }
            if (castling.q && !board[0][1] && !board[0][2] && !board[0][3] && !isSquareAttacked(2,0,'w') && !isSquareAttacked(3,0,'w')){
              moves.push({sx:x,sy:y,tx:2,ty:0, isCastle:true});
            }
          }
        }
      }
    }
    return moves;
  }

  function generateLegalMoves(color){
    // generate pseudo-legal, then make/unmake to test for leaving own king in check
    const pseudo = generatePseudoLegalMoves(color);
    const legal = [];
    for (let m of pseudo){
      // prepare move object
      const move = makeMoveObj(m.sx,m.sy,m.tx,m.ty, m.promotion || null);
      move.isEnPassant = !!m.isEnPassant;
      move.isCastle = !!m.isCastle;
      // apply
      applyMove(move);
      const stillInCheck = inCheck(color);
      undoMove();
      if (!stillInCheck) legal.push({...move});
    }
    return legal;
  }

  // ---------- Game end detection ----------
  function gameStatus(){
    const legal = generateLegalMoves(sideToMove === 'w' ? 'w' : 'b');
    if (legal.length === 0){
      if (inCheck(sideToMove === 'w' ? 'w' : 'b')) return { result: 'checkmate', winner: sideToMove === 'w' ? 'b' : 'w' };
      else return { result: 'stalemate', winner: null };
    }
    // fifty-move or insufficient material and repetition not implemented (could be added)
    return { result: 'playing' };
  }

  // ---------- Evaluation ----------
  function evaluate(){
    let score = 0;
    for (let y=0;y<8;y++){
      for (let x=0;x<8;x++){
        const p = board[y][x];
        if (!p) continue;
        const lower = p.toLowerCase();
        const val = MAT[lower];
        const idx = y*8 + x;
        const pst = PST[lower] || new Array(64).fill(0);
        const psVal = (p === p.toUpperCase() ? 1 : -1) * pst[idx];
        score += (p === p.toUpperCase() ? 1 : -1) * val + psVal;
      }
    }
    // side to move small bonus
    return score * (sideToMove === 'w' ? 1 : -1);
  }

  // ---------- Move ordering ----------
  function scoreMoveForOrdering(m){
    // captures prioritized by MVV-LVA
    if (m.capture){
      const victim = m.capture.toLowerCase();
      const attacker = m.piece.toLowerCase();
      return (MAT[victim] * 10) - MAT[attacker];
    }
    if (m.promotion) return 2000;
    return 0;
  }

  // ---------- Zobrist-like key (simple) ----------
  function positionKey(){
    // simple string key: board rows + side + castling + ep
    return board.flat().map(s => s ? s : '.').join('') + ' ' + sideToMove + ' ' +
           (castling.K? 'K':'' ) + (castling.Q? 'Q':'') + (castling.k? 'k':'') + (castling.q? 'q':'') + ' ' +
           (enPassant? enPassant : '-');
  }

  // ---------- Search (iterative deepening + alpha-beta + tt) ----------
  let nodes = 0;
  function alphaBeta(depth, alpha, beta, maximizing){
    const key = positionKey() + ' ' + depth + ' ' + (maximizing? '1':'0');
    if (tt.has(key)) return tt.get(key);
    nodes++;
    if (depth === 0) {
      const v = evaluate();
      tt.set(key, v);
      return v;
    }
    const color = maximizing ? (sideToMove === 'w' ? 'w' : 'b') : opposite(sideToMove === 'w' ? 'w' : 'b');
    let moves = generateLegalMoves(maximizing ? sideToMove === 'w' ? 'w' : 'b' : opposite(sideToMove === 'w' ? 'w' : 'b'));
    // ordering
    moves.sort((a,b) => scoreMoveForOrdering(b) - scoreMoveForOrdering(a));
    if (moves.length === 0){
      // checkmate or stalemate handled earlier; here depth>0 and no moves -> evaluate
      const v = evaluate();
      tt.set(key, v);
      return v;
    }
    if (maximizing){
      let value = -Infinity;
      for (let m of moves){
        applyMove(m);
        const val = alphaBeta(depth-1, alpha, beta, false);
        undoMove();
        if (val > value) value = val;
        if (val > alpha) alpha = val;
        if (alpha >= beta) break;
      }
      tt.set(key, value);
      return value;
    } else {
      let value = Infinity;
      for (let m of moves){
        applyMove(m);
        const val = alphaBeta(depth-1, alpha, beta, true);
        undoMove();
        if (val < value) value = val;
        if (val < beta) beta = val;
        if (alpha >= beta) break;
      }
      tt.set(key, value);
      return value;
    }
  }

  async function thinkAndMove(maxDepth){
    // iterative deepening with small time slices so browser remains responsive
    statusLabel.textContent = "Thinking...";
    nodes = 0;
    tt.clear();
    let bestMove = null;
    for (let depth = 1; depth <= maxDepth; depth++){
      let bestScore = -Infinity;
      let moves = generateLegalMoves('b'); // AI is always black here
      moves.sort((a,b) => scoreMoveForOrdering(b) - scoreMoveForOrdering(a));
      for (let m of moves){
        applyMove(m);
        const score = alphaBeta(depth-1, -Infinity, Infinity, true); // maximize for white after AI move
        undoMove();
        if (score > bestScore){
          bestScore = score;
          bestMove = m;
        }
      }
      // update status
      statusLabel.textContent = `Depth ${depth} searched — nodes ${nodes} — best ${bestScore}`;
      // yield to UI
      await new Promise(r => setTimeout(r, 10));
    }
    // apply resulting best move (if any)
    if (bestMove){
      applyMove(bestMove);
      drawBoardUI();
    }
    statusLabel.textContent = "Move done";
  }

  // ---------- Click handlers ----------
  canvas.onclick = async (ev) => {
    if (sideToMove !== 'w') return; // only allow human when white
    const rect = canvas.getBoundingClientRect();
    const cx = ev.clientX - rect.left;
    const cy = ev.clientY - rect.top;
    const x = Math.floor(cx / TILE), y = Math.floor(cy / TILE);

    // if no selected, select own piece
    if (!selected){
      const p = board[y][x];
      if (p && pieceColor(p) === 'w'){
        selected = {x,y};
        legalMovesCache = generateLegalMoves('w');
      }
    } else {
      // attempt to find a legal move from selected to clicked square
      const allLegal = generateLegalMoves('w');
      const candidate = allLegal.find(m => m.sx === selected.x && m.sy === selected.y && m.tx === x && m.ty === y);
      if (candidate){
        // if promotion, prompt
        if (candidate.promotion && !candidate.promotionSpecified){
          // ask quickly: Q/R/B/N
          const choice = prompt("Promote to (Q/R/B/N). Default Q").toUpperCase() || "Q";
          const prom = {'Q':'Q','R':'R','B':'B','N':'N'}[choice] || 'Q';
          candidate.promotion = prom;
        }
        applyMove(candidate);
        selected = null;
        legalMovesCache = [];
        drawBoardUI();
        // check game status
        const st = gameStatus();
        if (st.result === 'playing'){
          // AI move
          sideToMove = 'b';
          turnLabel.textContent = "Black (AI)";
          const depth = Number(difficultySelect.value);
          await thinkAndMove(depth);
          // after AI, check status
          const st2 = gameStatus();
          if (st2.result === 'checkmate'){
            statusLabel.textContent = `Checkmate — ${st2.winner==='w'?'White':'Black'} wins`;
          } else if (st2.result === 'stalemate'){
            statusLabel.textContent = 'Stalemate (draw)';
          } else {
            statusLabel.textContent = "Your move";
          }
        } else {
          if (st.result === 'checkmate') statusLabel.textContent = `Checkmate — ${st.winner==='w'?'White':'Black'} wins`;
          else statusLabel.textContent = 'Stalemate (draw)';
        }
      } else {
        // select another own piece if clicked own piece
        const p2 = board[y][x];
        if (p2 && pieceColor(p2) === 'w'){ selected = {x,y}; legalMovesCache = generateLegalMoves('w'); }
        else { selected = null; legalMovesCache = []; }
      }
    }
    drawBoardUI();
  };

  undoBtn.onclick = () => {
    undoMove();
    if (sideToMove === 'b' && history.length) { // undo AI's previous move too
      undoMove();
    }
    selected = null;
    legalMovesCache = [];
    drawBoardUI();
    statusLabel.textContent = "Undone";
  };

  resetBtn.onclick = () => {
    // reset all global state
    board = [
      ["r","n","b","q","k","b","n","r"],
      ["p","p","p","p","p","p","p","p"],
      ["","","","","","","",""],
      ["","","","","","","",""],
      ["","","","","","","",""],
      ["","","","","","","",""],
      ["P","P","P","P","P","P","P","P"],
      ["R","N","B","Q","K","B","N","R"]
    ];
    sideToMove = 'w';
    castling = { K:true, Q:true, k:true, q:true };
    enPassant = null;
    halfmoveClock = 0;
    fullmoveNumber = 1;
    history.length = 0;
    tt.clear();
    selected = null;
    legalMovesCache = [];
    drawBoardUI();
    statusLabel.textContent = "Reset";
  };

  // ---------- Start ----------
  drawBoardUI();
  statusLabel.textContent = "Ready";
})();
</script>
</body>
</html>
