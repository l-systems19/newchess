<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Othello â€” Responsive (fixed) â€” Strong AI</title>
  <meta name="description" content="Othello (Reversi) â€” original game logic preserved, UI fixes for mobile/desktop." />
  <style>
    /* Minimal UI polish only â€” logic in the script is unchanged */
    :root{
      --bg:#0b1220;
      --panel:#0b1220;
      --accent:#10b981;
      --muted:#94a3b8;
      --card:#0f1720;
    }
    html,body{height:100%;margin:0;background:var(--bg);font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;color:#e6eef6}
    .wrap{min-height:100vh;display:flex;align-items:flex-start;justify-content:center;padding:20px;box-sizing:border-box}
    .app{display:flex;gap:20px;align-items:flex-start;width:100%;max-width:1100px}
    .board-card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:14px;border-radius:12px;box-shadow:0 8px 28px rgba(0,0,0,0.6);display:flex;flex-direction:column;align-items:center}
    .board-wrap{display:flex;align-items:center;justify-content:center}
    canvas{display:block;border-radius:8px;touch-action:none}
    .panel{width:320px;background:var(--card);padding:16px;border-radius:12px;box-shadow:0 8px 28px rgba(0,0,0,0.6);display:flex;flex-direction:column;gap:12px}
    .muted{color:var(--muted);font-size:13px}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    button {cursor:pointer;padding:10px 12px;border-radius:10px;border:none;font-weight:600}
    .primary{background:linear-gradient(180deg,var(--accent),#059669);color:white}
    .secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
    select{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:#e6eef6}
    @media(max-width:880px){
      .app{flex-direction:column;align-items:center}
      .panel{width:100%}
    }
    .header{display:flex;justify-content:space-between;align-items:center;width:100%}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="app">
      <div class="board-card" id="boardCard">
        <div class="header" style="width:100%;margin-bottom:8px">
          <div>
            <div style="font-weight:700;font-size:16px">Othello / Reversi</div>
            <div class="muted" style="font-size:13px">Original logic preserved â€” UI fixed for devices</div>
          </div>
          <div class="muted">Turn: <span id="turn">Black</span></div>
        </div>
        <div class="board-wrap">
          <!-- canvas will be created by the script below -->
          <canvas id="othelloCanvas" aria-label="Othello board"></canvas>
        </div>
      </div>

      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:700">Controls</div>
          <div class="muted">Version: 1.0</div>
        </div>

        <div style="display:flex;gap:12px;align-items:center">
          <div class="muted">Score â€” Black: <b id="scoreB">2</b></div>
          <div class="muted">White: <b id="scoreW">2</b></div>
        </div>

        <div style="display:flex;align-items:center;gap:8px">
          <label class="muted">Difficulty</label>
          <select id="difficulty">
            <option value="2">Easy (2)</option>
            <option value="3" selected>Normal (3)</option>
            <option value="4">Hard (4)</option>
            <option value="5">Very Hard (5)</option>
          </select>
        </div>

        <div class="controls">
          <button id="hint" class="primary">ðŸ’¡ Hint</button>
          <button id="undo" class="secondary">â†º Undo</button>
          <button id="reset" class="secondary">Reset</button>
        </div>

        <div class="muted" style="font-size:13px">Tap / click a highlighted square to place your disc. If you have no legal moves you'll pass automatically.</div>

        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="muted">Status: <span id="status">Ready</span></div>
          <div></div>
        </div>
      </div>
    </div>
  </div>

<script>
/*
  IMPORTANT:
  - I kept your original game logic and AI exactly as you provided.
  - The only changes are UI/input/canvas sizing so it works on mobile & desktop.
  - The internal functions (flipsForMove, legalMoves, applyMove, evaluate, alphaBeta, thinkAndMove, etc.)
    are the same as your original code.
*/

(() => {
  // --- UI wiring: create canvas and elements using the IDs in the HTML above ---
  const canvas = document.getElementById('othelloCanvas');
  const turnLabel = document.getElementById('turn');
  const statusLabel = document.getElementById('status');
  const scoreBLabel = document.getElementById('scoreB');
  const scoreWLabel = document.getElementById('scoreW');
  const difficultySelect = document.getElementById('difficulty');
  const hintBtn = document.getElementById('hint');
  const undoBtn = document.getElementById('undo');
  const resetBtn = document.getElementById('reset');

  // constants (we keep the same names your logic used)
  // but make SIZE/CELL responsive so UI works on all screens (this is a UI change only)
  let SIZE = 640;
  let CELL = SIZE / 8;

  function setupCanvasSize() {
    // choose a size that fits the viewport while keeping the board square
    const maxAvailable = Math.min(window.innerWidth - 60, 720);
    const target = Math.max(320, Math.min(640, maxAvailable));
    SIZE = target;
    const dpr = Math.max(1, window.devicePixelRatio || 1);

    canvas.style.width = SIZE + 'px';
    canvas.style.height = SIZE + 'px';
    canvas.width = Math.floor(SIZE * dpr);
    canvas.height = Math.floor(SIZE * dpr);

    const ctx = canvas.getContext('2d');
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // scale to CSS pixels
    CELL = SIZE / 8;
    return ctx;
  }

  // get a drawing context once and update it on resize
  let ctx = setupCanvasSize();
  window.addEventListener('resize', () => { ctx = setupCanvasSize(); draw(); });

  // ---------- Game State (unchanged logic) ----------
  // Board: 8x8 array. 0 empty, 1 black (human), -1 white (AI).
  let board = Array.from({ length: 8 }, () => Array(8).fill(0));
  board[3][3] = -1; board[3][4] = 1; board[4][3] = 1; board[4][4] = -1;

  let sideToMove = 1; // 1 = black (human), -1 = white (AI)
  let history = []; // stack of {board, side}
  const tt = new Map(); // transposition table

  // ---------- Utilities (identical to your logic) ----------
  function cloneBoard(b) { return b.map(r => r.slice()); }
  function inBounds(x, y) { return x >= 0 && x < 8 && y >= 0 && y < 8; }
  const DIRS = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
  function boardKey(b, side) { return b.flat().join(',') + '|' + side; }

  function flipsForMove(b, x, y, side) {
    if (b[y][x] !== 0) return [];
    const flips = [];
    for (const [dx, dy] of DIRS) {
      let nx = x + dx, ny = y + dy;
      const line = [];
      while (inBounds(nx, ny) && b[ny][nx] === -side) {
        line.push([nx, ny]);
        nx += dx; ny += dy;
      }
      if (line.length && inBounds(nx, ny) && b[ny][nx] === side) {
        flips.push(...line);
      }
    }
    return flips;
  }

  function legalMoves(b, side) {
    const moves = [];
    for (let y=0; y<8; y++) for (let x=0; x<8; x++) {
      const f = flipsForMove(b, x, y, side);
      if (f.length) moves.push({ x, y, flips: f });
    }
    return moves;
  }

  function applyMove(b, move, side) {
    const nb = cloneBoard(b);
    nb[move.y][move.x] = side;
    for (const [fx, fy] of move.flips) nb[fy][fx] = side;
    return nb;
  }

  function countPieces(b) {
    let black = 0, white = 0;
    for (let y=0;y<8;y++) for (let x=0;x<8;x++) {
      if (b[y][x] === 1) black++;
      else if (b[y][x] === -1) white++;
    }
    return { black, white };
  }

  function gameOverAndWinner(b) {
    const bMoves = legalMoves(b, 1);
    const wMoves = legalMoves(b, -1);
    if (bMoves.length || wMoves.length) return null;
    const c = countPieces(b);
    if (c.black > c.white) return { winner: 'Black', score: c };
    if (c.white > c.black) return { winner: 'White', score: c };
    return { winner: 'Draw', score: c };
  }

  const WEIGHTS = [
    [120, -20, 20, 5, 5, 20, -20, 120],
    [-20, -40, -5, -5, -5, -5, -40, -20],
    [20, -5, 15, 3, 3, 15, -5, 20],
    [5, -5, 3, 3, 3, 3, -5, 5],
    [5, -5, 3, 3, 3, 3, -5, 5],
    [20, -5, 15, 3, 3, 15, -5, 20],
    [-20, -40, -5, -5, -5, -5, -40, -20],
    [120, -20, 20, 5, 5, 20, -20, 120]
  ];

  function evaluate(b, side) {
    let posScore = 0;
    for (let y=0;y<8;y++) for (let x=0;x<8;x++) {
      posScore += (b[y][x] || 0) * WEIGHTS[y][x];
    }
    const myMob = legalMoves(b, side).length;
    const oppMob = legalMoves(b, -side).length;
    const mobility = 10 * (myMob - oppMob);
    const counts = countPieces(b);
    const parity = 2 * ((counts.black - counts.white) * (side === 1 ? 1 : -1));
    const score = posScore + mobility + parity;
    return score * (side === 1 ? 1 : -1);
  }

  function orderMoves(moves, b, side) {
    return moves.slice().sort((a, c) => {
      const aCorner = (a.x===0&&a.y===0) || (a.x===7&&a.y===0) || (a.x===0&&a.y===7) || (a.x===7&&a.y===7);
      const cCorner = (c.x===0&&c.y===0) || (c.x===7&&c.y===0) || (c.x===0&&c.y===7) || (c.x===7&&c.y===7);
      if (aCorner !== cCorner) return (aCorner ? -1 : 1);
      return c.flips.length - a.flips.length;
    });
  }

  // alpha-beta + iterative deepening + TT (unchanged)
  let nodes = 0;
  async function thinkAndMove(maxDepth) {
    statusLabel.textContent = "AI thinking...";
    turnLabel.textContent = "White (AI)";
    const startKey = boardKey(board, sideToMove);
    tt.clear();
    nodes = 0;
    let bestMove = null;
    for (let depth = 1; depth <= maxDepth; depth++) {
      let bestVal = -Infinity;
      const moves = orderMoves(legalMoves(board, -1), board, -1);
      if (!moves.length) { bestMove = null; break; }
      for (const m of moves) {
        nodes++;
        const nb = applyMove(board, m, -1);
        const val = await alphaBeta(nb, depth - 1, -Infinity, Infinity, 1);
        if (val > bestVal) { bestVal = val; bestMove = m; }
      }
      statusLabel.textContent = `Depth ${depth} â€” nodes ${nodes} â€” best ${bestVal.toFixed(1)}`;
      await new Promise(r => setTimeout(r, 10));
    }
    if (bestMove) {
      history.push({ board: cloneBoard(board), side: sideToMove });
      board = applyMove(board, bestMove, -1);
      sideToMove = 1;
      draw();
      const g = gameOverAndWinner(board);
      if (g) {
        statusLabel.textContent = `Game over: ${g.winner} (${g.score.black} - ${g.score.white})`;
      } else {
        statusLabel.textContent = "Your move";
      }
    } else {
      statusLabel.textContent = "AI passes";
      sideToMove = 1;
      draw();
    }
  }

  async function alphaBeta(b, depth, alpha, beta, side) {
    const key = boardKey(b, side) + '|' + depth;
    if (tt.has(key)) return tt.get(key);
    if (depth === 0) {
      const v = evaluate(b, -1);
      tt.set(key, v);
      return v;
    }
    const moves = orderMoves(legalMoves(b, side), b, side);
    if (!moves.length) {
      const oppMoves = orderMoves(legalMoves(b, -side), b, -side);
      if (!oppMoves.length) {
        const counts = countPieces(b);
        const finalScore = (counts.white - counts.black) * 1000;
        tt.set(key, finalScore);
        return finalScore * (side === -1 ? 1 : -1);
      } else {
        const val = -await alphaBeta(b, depth - 1, -beta, -alpha, -side);
        tt.set(key, val);
        return val;
      }
    }
    let value = -Infinity;
    for (const m of moves) {
      const nb = applyMove(b, m, side);
      const score = -await alphaBeta(nb, depth - 1, -beta, -alpha, -side);
      if (score > value) value = score;
      if (value > alpha) alpha = value;
      if (alpha >= beta) break;
    }
    tt.set(key, value);
    return value;
  }

  // ---------- Drawing (unchanged visual style except scaled properly) ----------
  function draw() {
    ctx = canvas.getContext('2d'); // ensure ctx matches current canvas transform
    ctx.clearRect(0,0,SIZE,SIZE);
    // background
    ctx.fillStyle = "#006400";
    ctx.fillRect(0,0,SIZE,SIZE);
    // board squares
    for (let y=0;y<8;y++) for (let x=0;x<8;x++) {
      ctx.fillStyle = (x + y) % 2 === 0 ? "#2f8f2f" : "#1f5f1f";
      ctx.fillRect(x*CELL, y*CELL, CELL, CELL);
    }
    // grid
    ctx.strokeStyle = "rgba(0,0,0,0.6)";
    for (let i=0;i<=8;i++) {
      ctx.beginPath();
      ctx.moveTo(i*CELL, 0); ctx.lineTo(i*CELL, SIZE); ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0, i*CELL); ctx.lineTo(SIZE, i*CELL); ctx.stroke();
    }

    // legal moves highlight
    const moves = legalMoves(board, sideToMove);
    for (const m of moves) {
      ctx.beginPath();
      ctx.fillStyle = "rgba(255,255,255,0.35)";
      ctx.arc(m.x*CELL + CELL/2, m.y*CELL + CELL/2, CELL*0.13, 0, Math.PI*2);
      ctx.fill();
    }

    // discs
    for (let y=0;y<8;y++) for (let x=0;x<8;x++) {
      if (board[y][x] === 0) continue;
      const cx = x*CELL + CELL/2, cy = y*CELL + CELL/2;
      ctx.beginPath();
      ctx.fillStyle = board[y][x] === 1 ? "#000" : "#fff";
      ctx.arc(cx, cy, CELL*0.38, 0, Math.PI*2);
      ctx.fill();
      // subtle edge
      ctx.lineWidth = 2;
      ctx.strokeStyle = board[y][x] === 1 ? "rgba(255,255,255,0.15)" : "rgba(0,0,0,0.15)";
      ctx.stroke();
    }

    // update labels
    const c = countPieces(board);
    scoreBLabel.textContent = c.black;
    scoreWLabel.textContent = c.white;
    turnLabel.textContent = sideToMove === 1 ? "Black (You)" : "White (AI)";
  }

  // ---------- Interaction: pointer/touch handling (UI fix) ----------
  function getBoardPosFromPointer(ev) {
    const rect = canvas.getBoundingClientRect();
    let clientX = ev.clientX, clientY = ev.clientY;
    if (ev.touches && ev.touches[0]) {
      clientX = ev.touches[0].clientX;
      clientY = ev.touches[0].clientY;
    }
    // use rect.width/height to be robust to CSS scaling
    const px = clientX - rect.left;
    const py = clientY - rect.top;
    const x = Math.floor(px / (rect.width / 8));
    const y = Math.floor(py / (rect.height / 8));
    return { x, y };
  }

  // Use pointerdown for better cross-device reliability
  canvas.addEventListener('pointerdown', async (ev) => {
    ev.preventDefault();
    if (sideToMove !== 1) return;
    const pos = getBoardPosFromPointer(ev);
    const x = pos.x, y = pos.y;
    if (!inBounds(x,y)) return;
    const moves = legalMoves(board, 1);
    const chosen = moves.find(m => m.x === x && m.y === y);
    if (chosen) {
      history.push({ board: cloneBoard(board), side: sideToMove });
      board = applyMove(board, chosen, 1);
      sideToMove = -1;
      draw();
      const over = gameOverAndWinner(board);
      if (over) {
        statusLabel.textContent = `Game over: ${over.winner} (${over.score.black} - ${over.score.white})`;
        return;
      }
      await thinkAndMove(Number(difficultySelect.value));
    }
    draw();
  });

  // ---------- Hint / Undo / Reset (UI only) ----------
  hintBtn.addEventListener('click', async () => {
    statusLabel.textContent = "Calculating hint...";
    const depth = Math.max(1, Math.min(4, Number(difficultySelect.value)));
    const moves = orderMoves(legalMoves(board, 1), board, 1);
    if (!moves.length) { statusLabel.textContent = "No legal moves (you will pass)"; return; }
    let best = null, bestVal = -Infinity;
    for (const m of moves) {
      const nb = applyMove(board, m, 1);
      const v = await alphaBeta(nb, depth - 1, -Infinity, Infinity, -1);
      if (v > bestVal) { bestVal = v; best = m; }
    }
    if (best) {
      const cx = best.x*CELL + CELL/2, cy = best.y*CELL + CELL/2;
      const tot = 6;
      for (let i=0;i<tot;i++){
        ctx.beginPath();
        ctx.fillStyle = `rgba(255,255,0,${0.15 + 0.12 * (tot - i)})`;
        ctx.arc(cx, cy, CELL*0.15 + i*2, 0, Math.PI*2);
        ctx.fill();
      }
      statusLabel.textContent = `Hint shown (eval ${bestVal.toFixed(1)})`;
      setTimeout(draw, 600);
    } else statusLabel.textContent = "No hint available";
  });

  undoBtn.addEventListener('click', () => {
    const last = history.pop();
    if (last) {
      board = last.board;
      sideToMove = last.side;
    }
    draw();
    statusLabel.textContent = "Undone";
  });

  resetBtn.addEventListener('click', () => {
    board = Array.from({ length: 8 }, () => Array(8).fill(0));
    board[3][3] = -1; board[3][4] = 1; board[4][3] = 1; board[4][4] = -1;
    sideToMove = 1;
    history = [];
    tt.clear();
    draw();
    statusLabel.textContent = "Reset";
  });

  // ---------- Start ----------
  draw();
  statusLabel.textContent = "Ready";

  // handle auto-passing at start if necessary (same behavior)
  (async () => {
    const humanMoves = legalMoves(board, 1);
    if (!humanMoves.length) {
      statusLabel.textContent = "You have no moves â€” passing to AI";
      sideToMove = -1;
      await thinkAndMove(Number(difficultySelect.value));
    }
  })();

})(); // end IIFE
</script>
</body>
</html>
